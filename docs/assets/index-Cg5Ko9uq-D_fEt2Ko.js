import{p as F,q as D,f as $,X as j,A as v,c as B,v as T,C as ne,O as oe,k as P,w as R,S as X,E as ie,T as x,j as ae,I as se}from"./sui-B_AxArCa-Dtu7uBWp.js";import{dP as N,ao as ce,dQ as H,dR as C,cC as de,cY as M,cI as le,cZ as z,cG as _,ar as O,a6 as I,cE as ue,d1 as Y,b2 as ge,dS as he,cJ as W,ap as fe,ab as S,ac as pe,dC as we,ds as G,dT as ye,dU as me,aq as K,cN as L}from"./index-BGLdF6jF.js";import"./index-CrKGOs08-iJOFHPhe.js";import{h as Z}from"./unsignedTransaction-BD81leu1-Cw-cn2l3.js";import"./blake2b-CAi92fbu-C8y-5OqJ.js";import"./index-wFZO7Yy8-CgrhUj91.js";var be=Object.defineProperty,ke=(k,t,e)=>t in k?be(k,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):k[t]=e,y=(k,t,e)=>ke(k,typeof t!="symbol"?t+"":t,e);const Q=async(k,t,e)=>{var a,o,s;if(!N(e))throw new Error(`Invalid Sui type: ${e}`);const c=await F(k,t);if(!c)throw new Error(`Unable to fetch object fields from token bridge state. Object ID: ${t}`);const i=(o=(a=c.token_registry.fields)==null?void 0:a.id)==null?void 0:o.id;if(!i)throw new Error("Unable to fetch token registry object ID");const n=ce((s=c.token_registry)==null?void 0:s.type);if(!n)throw new Error("Unable to fetch token registry package ID");return k.getDynamicFieldObject({parentId:i,name:{type:`${n}::token_registry::Key<${e}>`,value:{dummy_field:!1}}})},U=async(k,t,e,a)=>{var o,s,c,i;const n=await F(k,t);if(!n)throw new Error("Unable to fetch object fields from token bridge state");const r=(s=(o=n.token_registry)==null?void 0:o.fields)==null?void 0:s.coin_types,u=(i=(c=r==null?void 0:r.fields)==null?void 0:c.id)==null?void 0:i.id;if(!u)throw new Error("Unable to fetch coin types");const l=H(r==null?void 0:r.type);if(!l)throw new Error("Unable to get key type");const g=await k.getDynamicFieldObject({parentId:u,name:{type:l,value:{addr:[...e],chain:a}}});if(g.error){if(g.error.code==="dynamicFieldNotFound")return null;throw new Error(`Unexpected getDynamicFieldObject response ${g.error}`)}const f=D(g);if(!f)return null;if(!$(f))throw new Error("What?");return"value"in f?C(f.value):null};class q{constructor(t,e,a,o){y(this,"network"),y(this,"chain"),y(this,"provider"),y(this,"contracts"),y(this,"coreBridgeObjectId"),y(this,"tokenBridgeObjectId"),y(this,"chainId"),this.network=t,this.chain=e,this.provider=a,this.contracts=o,this.chainId=de.get(t,e);const s=this.contracts.tokenBridge;if(!s)throw new Error(`Wormhole Token Bridge contract for domain ${e} not found`);const c=this.contracts.coreBridge;if(!c)throw new Error(`Wormhole Token Bridge contract for domain ${e} not found`);this.tokenBridgeObjectId=s,this.coreBridgeObjectId=c}static async fromRpc(t,e){const[a,o]=await j.chainFromRpc(t),s=e[o];if(s.network!==a)throw new Error(`Network mismatch: ${s.network} != ${a}`);return new q(a,o,t,s.contracts)}async isWrappedAsset(t){try{return await this.getOriginalAsset(t),!0}catch{return!1}}async getOriginalAsset(t){let e=t.getCoinType();if(!N(e))throw new Error(`Invalid Sui type: ${e}`);const a=await Q(this.provider,this.tokenBridgeObjectId,e),o=D(a);if(!o)throw M(e);if(!$(o))throw new Error("Expected fields to be a MoveStruct");if(!("value"in o))throw new Error("Expected a `value` key in fields of MoveStruct");const s=o.value;if(!v(s))throw new Error("Expected fields to be a MoveStruct");const c=C(s.type);if(e=C(e),c.includes(`wrapped_asset::WrappedAsset<${e}>`)){const i=s.fields.info;if(!v(i))throw new Error("Expected fields to be a MoveStruct");const n=i.fields.token_address;if(!v(n))throw new Error("Expected fields to be a MoveStruct");if(!$(n.fields))throw new Error("Expected address data to be a MoveObject");if(!("value"in n.fields))throw new Error("Expected a `value` key in fields of MoveStruct");const r=n.fields.value;if(!v(r))throw new Error("Expected fields to be a MoveStruct");const u=new Uint8Array(r.fields.data);return{chain:le(Number(i.fields.token_chain)),address:new z(u)}}throw M(e)}async getTokenUniversalAddress(t){let e=t.getCoinType();if(!N(e))throw new Error(`Invalid Sui type: ${e}`);const a=await Q(this.provider,this.tokenBridgeObjectId,e),o=D(a);if(!o)throw new Error(`Token of type ${e} has not been registered with the token bridge. Has it been attested?`);if(!$(o))throw new Error("Expected fields to be a MoveStruct");if(!("value"in o))throw new Error("Expected a `value` key in fields of MoveStruct");const s=o.value;if(!v(s))throw new Error("Expected fields to be a MoveStruct");const c=C(s.type);if(e=C(e),c.includes(`native_asset::NativeAsset<${e}>`)){const i=s.fields.token_address;if(!v(i))throw new Error("Expected fields to be a MoveStruct");if(!("value"in i.fields))throw new Error("Expected a `value` key in fields of MoveStruct");const n=i.fields.value;if(!v(n))throw new Error("Expected fields to be a MoveStruct");const r=new Uint8Array(n.fields.data);return new z(r)}throw new Error(`Token of type ${e} is not a native asset`)}async getTokenNativeAddress(t,e){const a=await U(this.provider,this.tokenBridgeObjectId,e.toUint8Array(),_(t));if(!a)throw new Error(`Token ${e.toString()} not found in token registry`);return new O(a)}async hasWrappedAsset(t){try{return await this.getWrappedAsset(t),!0}catch{}return!1}async getWrappedAsset(t){if(I(t.address))throw new Error("Token Address required, 'native' literal not supported");const e=await U(this.provider,this.tokenBridgeObjectId,t.address.toUniversalAddress().toUint8Array(),_(t.chain));if(!e)throw M(ue(t));return Y(this.chain,e)}async isTransferCompleted(t){var e,a,o,s,c,i,n,r;const u=await F(this.provider,this.tokenBridgeObjectId);if(!u)throw new Error("Unable to fetch object fields from token bridge state");const l=(a=(e=u.consumed_vaas)==null?void 0:e.fields)==null?void 0:a.hashes,g=H((s=(o=l==null?void 0:l.fields)==null?void 0:o.items)==null?void 0:s.type);if(!g)throw new Error("Unable to get key type");const f=(r=(n=(i=(c=l==null?void 0:l.fields)==null?void 0:c.items)==null?void 0:i.fields)==null?void 0:n.id)==null?void 0:r.id;if(!f)throw new Error("Unable to fetch consumed VAAs table");const p=await this.provider.getDynamicFieldObject({parentId:f,name:{type:g,value:{data:[...ge(t.hash)]}}});if(!p.error)return!0;if(p.error.code==="dynamicFieldNotFound")return!1;throw new Error(`Unexpected getDynamicFieldObject response ${p.error}`)}async*createAttestation(t){const e=0n,a=t.toString(),o=await this.provider.getCoinMetadata({coinType:a});if(o===null||o.id===null)throw new Error(`Coin metadata ID for type ${a} not found`);const[s,c]=await this.getPackageIds(),i=new B,[n]=i.splitCoins(i.gas,[i.pure.u64(e)]),[r]=i.moveCall({target:`${c}::attest_token::attest_token`,arguments:[i.object(this.tokenBridgeObjectId),i.object(o.id),i.pure.u32(0)],typeArguments:[a]});i.moveCall({target:`${s}::publish_message::publish_message`,arguments:[i.object(this.coreBridgeObjectId),n,r,i.object(T)]}),yield this.createUnsignedTx(i,"Sui.TokenBridge.CreateAttestation")}async*submitAttestation(t,e){const[a,o]=await this.getPackageIds(),s=e.toString(),c=Math.min(t.payload.decimals,8),i=await this.getCoinBuildOutput(a,o,c),n=await ne(i,s);yield this.createUnsignedTx(n,"Sui.TokenBridge.PrepareCreateWrapped");let r="",u="",l="",g="",f="",p=!1;for(;!p;){await new Promise(b=>setTimeout(b,500));const m=await this.provider.queryTransactionBlocks({filter:{FromAddress:s},options:{showObjectChanges:!0},limit:3});for(const b of m.data)if("objectChanges"in b){for(const h of b.objectChanges)oe(h)&&h.packageId!==void 0?r=h.packageId:P(h)&&h.objectType.includes("WrappedAssetSetup")?(u=h.objectId,f=h.objectType.split(", ")[1].replace(">","")):P(h)&&h.objectType.includes("UpgradeCap")?l=h.objectId:P(h)&&h.objectType.includes("CoinMetadata")&&(g=h.objectId);if(r!==""&&u!==""&&l!==""&&g!==""){p=!0;break}else r="",u="",l="",g=""}}const d=he(r),w=new B,[A]=w.moveCall({target:`${a}::vaa::parse_and_verify`,arguments:[w.object(this.coreBridgeObjectId),w.pure.vector("u8",W(t)),w.object(T)]}),[E]=w.moveCall({target:`${o}::vaa::verify_only_once`,arguments:[w.object(this.tokenBridgeObjectId),A]});w.moveCall({target:`${o}::create_wrapped::complete_registration`,arguments:[w.object(this.tokenBridgeObjectId),w.object(g),w.object(u),w.object(l),E],typeArguments:[d,f]}),yield this.createUnsignedTx(w,"Sui.TokenBridge.SubmitAttestation")}async*transfer(t,e,a,o,s){const c=0n,i=0n,n=t.toString(),r=(I(a)?R:a).toString(),u=await j.getCoins(this.provider,t,r),[l,...g]=u.filter(m=>X(m.coinType,r));if(l===void 0)throw new Error(`Coins array doesn't contain any coins of type ${r}`);const[f,p]=await this.getPackageIds(),d=new B,[w]=(()=>{if(r===R)return d.splitCoins(d.gas,[d.pure.u64(o)]);{const m=d.object(l.coinObjectId);return g.length&&d.mergeCoins(m,g.map(b=>d.object(b.coinObjectId))),d.splitCoins(m,[d.pure.u64(o)])}})(),[A]=d.splitCoins(d.gas,[d.pure.u64(c)]),[E]=d.moveCall({target:`${p}::state::verified_asset`,arguments:[d.object(this.tokenBridgeObjectId)],typeArguments:[r]});if(s){if(!n)throw new Error("senderAddress is required for transfer with payload");let m=!1;const b=await(async()=>{const V=await ie(this.provider,f,n);if(V!==null)return d.object(V);{const[re]=d.moveCall({target:`${f}::emitter::new`,arguments:[d.object(this.coreBridgeObjectId)]});return m=!0,re}})(),[h,ee]=d.moveCall({target:`${p}::transfer_tokens_with_payload::prepare_transfer`,arguments:[b,E,w,d.pure.u16(_(e.chain)),d.pure.vector("u8",e.address.toUint8Array()),d.pure.vector("u8",s),d.pure.u32(0)],typeArguments:[r]});d.moveCall({target:`${p}::coin_utils::return_nonzero`,arguments:[ee],typeArguments:[r]});const[te]=d.moveCall({target:`${p}::transfer_tokens_with_payload::transfer_tokens_with_payload`,arguments:[d.object(this.tokenBridgeObjectId),h],typeArguments:[r]});d.moveCall({target:`${f}::publish_message::publish_message`,arguments:[d.object(this.coreBridgeObjectId),A,te,d.object(T)]}),m&&d.transferObjects([b],d.pure.address(n)),yield this.createUnsignedTx(d,"Sui.TokenBridge.TransferWithPayload")}else{const[m,b]=d.moveCall({target:`${p}::transfer_tokens::prepare_transfer`,arguments:[E,w,d.pure.u16(_(e.chain)),d.pure.vector("u8",e.address.toUint8Array()),d.pure.u64(i),d.pure.u32(0)],typeArguments:[r]});d.moveCall({target:`${p}::coin_utils::return_nonzero`,arguments:[b],typeArguments:[r]});const[h]=d.moveCall({target:`${p}::transfer_tokens::transfer_tokens`,arguments:[d.object(this.tokenBridgeObjectId),m],typeArguments:[r]});d.moveCall({target:`${f}::publish_message::publish_message`,arguments:[d.object(this.coreBridgeObjectId),A,h,d.object(T)]}),yield this.createUnsignedTx(d,"Sui.TokenBridge.Transfer")}}async*redeem(t,e,a=!0){const o=await U(this.provider,this.tokenBridgeObjectId,e.payload.token.address.toUint8Array(),_(e.payload.token.chain));if(!o)throw new Error("Unable to fetch token coinType");const[s,c]=await this.getPackageIds(),i=new B,[n]=i.moveCall({target:`${s}::vaa::parse_and_verify`,arguments:[i.object(this.coreBridgeObjectId),i.pure.vector("u8",W(e)),i.object(T)]}),[r]=i.moveCall({target:`${c}::vaa::verify_only_once`,arguments:[i.object(this.tokenBridgeObjectId),n]}),[u]=i.moveCall({target:`${c}::complete_transfer::authorize_transfer`,arguments:[i.object(this.tokenBridgeObjectId),r],typeArguments:[o]}),[l]=i.moveCall({target:`${c}::complete_transfer::redeem_relayer_payout`,arguments:[u],typeArguments:[o]});i.moveCall({target:`${c}::coin_utils::return_nonzero`,arguments:[l],typeArguments:[o]}),yield this.createUnsignedTx(i,"Sui.TokenBridge.Redeem")}async getWrappedNative(){return Y(this.chain,R)}async getPackageIds(){return Promise.all([x(this.provider,this.coreBridgeObjectId),x(this.provider,this.tokenBridgeObjectId)])}async getCoinBuildOutput(t,e,a){var o;if(a>8)throw new Error("Decimals is capped at 8");const s=(o=await ae(this.provider,this.tokenBridgeObjectId))==null?void 0:o.replace("0x","");if(!s)throw new Error(`Original token bridge package ID not found for object ID ${this.tokenBridgeObjectId}`);const c="a11ceb0b060000000901000a020a14031e1704350405392d07669f01088502600ae502050cea02160004010b010c0205020d000002000201020003030c020001000104020700000700010001090801010c020a050600030803040202000302010702080007080100020800080303090002070801010b020209000901010608010105010b0202080008030209000504434f494e095478436f6e7465787408565f5f305f325f3011577261707065644173736574536574757004636f696e0e6372656174655f777261707065640b64756d6d795f6669656c6404696e697414707265706172655f726567697374726174696f6e0f7075626c69635f7472616e736665720673656e646572087472616e736665720a74785f636f6e746578740f76657273696f6e5f636f6e74726f6c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002"+s+"00020106010000000001090b0031"+a.toString(16).padStart(2,"0")+"0a0138000b012e110238010200";return{modules:[fe.encode(S.decode(c))],dependencies:["0x1","0x2",e,t].map(i=>pe(i))}}createUnsignedTx(t,e,a=!1){return new Z(t,this.network,this.chain,e,a)}}class J{constructor(t,e,a,o){y(this,"network"),y(this,"chain"),y(this,"connection"),y(this,"contracts"),y(this,"tokenBridgeRelayerObjectId"),y(this,"coreBridgeObjectId"),y(this,"tokenBridgeObjectId"),y(this,"fields"),this.network=t,this.chain=e,this.connection=a,this.contracts=o;const{tokenBridge:s,tokenBridgeRelayer:c,coreBridge:i}=o;if(!s||!c||!i)throw new Error(`Some object IDs for ${e} Automatic Token Bridge not found`);this.tokenBridgeRelayerObjectId=c,this.tokenBridgeObjectId=s,this.coreBridgeObjectId=i}static async fromRpc(t,e){const[a,o]=await j.chainFromRpc(t),s=e[o];if(s.network!==a)throw new Error(`Network mismatch for chain ${o}: ${s.network} != ${a}`);return new J(a,o,t,s.contracts)}async*transfer(t,e,a,o,s){const c=new O(I(a)?j.nativeTokenId(this.network,this.chain).address:a).getCoinType(),{coreBridge:i,tokenBridge:n}=await this.getPackageIds(),r=new B,u=BigInt(0),[l]=r.splitCoins(r.gas,[r.pure.u64(u)]),[g]=await(async()=>{if(I(a))return r.splitCoins(r.gas,[r.pure.u64(o)]);{const A=await j.getCoins(this.connection,t,c),[E,...m]=A.filter(h=>h.coinType===c);if(E===void 0)throw new Error(`Coins array doesn't contain any coins of type ${c}`);const b=r.object(E.coinObjectId);return m.length&&r.mergeCoins(b,m.map(h=>r.object(h.coinObjectId))),r.splitCoins(b,[r.pure.u64(o)])}})(),[f]=r.moveCall({target:`${n}::state::verified_asset`,arguments:[r.object(this.tokenBridgeObjectId)],typeArguments:[c]}),p=await this.getPackageId(),[d]=r.moveCall({target:`${p}::transfer::transfer_tokens_with_relay`,arguments:[r.object(this.tokenBridgeRelayerObjectId),g,f,r.pure.u64(s??0n),r.pure.u16(_(e.chain)),r.pure.address(S.encode(e.address.toUint8Array(),!0)),r.pure.u32(123)],typeArguments:[c]}),[w]=r.moveCall({target:`${n}::transfer_tokens_with_payload::transfer_tokens_with_payload`,arguments:[r.object(this.tokenBridgeObjectId),d],typeArguments:[c]});r.moveCall({target:`${i}::publish_message::publish_message`,arguments:[r.object(this.coreBridgeObjectId),l,w,r.object(T)]}),yield this.createUnsignedTx(r,"AutomaticTokenBridge.transfer")}async*redeem(t,e){const{coreBridge:a,tokenBridge:o}=await this.getPackageIds(),{address:s,chain:c}=e.payload.token,i=await U(this.connection,this.tokenBridgeObjectId,s.toUniversalAddress().toUint8Array(),_(c));if(!i)throw new Error("Unable to fetch token coinType");const n=new B,[r]=n.moveCall({target:`${a}::vaa::parse_and_verify`,arguments:[n.object(this.coreBridgeObjectId),n.pure.vector("u8",W(e)),n.object(T)]}),[u]=n.moveCall({target:`${o}::vaa::verify_only_once`,arguments:[n.object(this.tokenBridgeObjectId),r]}),[l]=n.moveCall({target:`${o}::complete_transfer_with_payload::authorize_transfer`,arguments:[n.object(this.tokenBridgeObjectId),u],typeArguments:[i]}),g=await this.getPackageId();n.moveCall({target:`${g}::redeem::complete_transfer`,arguments:[n.object(this.tokenBridgeRelayerObjectId),l],typeArguments:[i]}),yield this.createUnsignedTx(n,"AutomaticTokenBridge.redeem")}async getRelayerFee(t,e){const a=I(e)?j.nativeTokenId(this.network,this.chain):e,o=await this.getTokenInfo(a.toString());if(o===null)throw new Error("Unsupported token for relay");const s=await this.getFields(),c=await this.connection.getDynamicFieldObject({parentId:this.tokenBridgeRelayerObjectId,name:{type:"vector<u8>",value:Array.from(we.encode("relayer_fees"))}});if(!c.data||!c.data.content)throw c.error?new Error("Failed to get relayer fees: "+JSON.stringify(c.error)):new Error("Unable to compute relayer fee");const{content:i}=c.data;if(!v(i)||!se(i.fields.id))throw new Error("Unable to compute relayer fee");const n=await this.connection.getDynamicFieldObject({parentId:i.fields.id.id,name:{type:"u16",value:_(t)}});if(!n.data||!n.data.content)throw n.error?new Error("Failed to get relayer fees: "+JSON.stringify(c.error)):new Error("Unable to compute relayer fee");const{content:r}=n.data;if(!v(r))throw new Error("Unable to compute relayer fee");const u=await j.getDecimals(this.chain,this.connection,e.toString()),l=o.swap_rate,g=s.relayer_fee_precision,f=s.swap_rate_precision,p=r.fields.value;return 10n**BigInt(u)*BigInt(p)*BigInt(f)/(BigInt(l)*BigInt(g))}async maxSwapAmount(t){var e,a;const o=(I(t)?j.nativeTokenId(this.network,this.chain):t).toString(),s=await this.connection.getCoinMetadata({coinType:o});if(!s)throw new Error("metadata is null");const c=await this.getPackageId(),i=new B;i.moveCall({target:`${c}::redeem::calculate_max_swap_amount_in`,arguments:[i.object(this.tokenBridgeRelayerObjectId),i.pure.u8(s.decimals)],typeArguments:[o]});const n=await this.connection.devInspectTransactionBlock({transactionBlock:i,sender:S.encode(new Uint8Array(32))});if(!n.results||n.results.length==0||!((e=n.results[0])!=null&&e.returnValues)||((a=n.results[0])==null?void 0:a.returnValues.length)!==1)throw Error("swap rate not set");return G.decode(new Uint8Array(n.results[0].returnValues[0][0].toReversed()))}async nativeTokenAmount(t,e){var a,o;const s=(I(t)?j.nativeTokenId(this.network,this.chain):t).toString(),c=await this.connection.getCoinMetadata({coinType:s});if(!c)throw new Error("metadata is null");const i=await this.getPackageId(),n=new B;n.moveCall({target:`${i}::redeem::calculate_native_swap_amount_out`,arguments:[n.object(this.tokenBridgeRelayerObjectId),n.pure.u64(e),n.pure.u8(c.decimals)],typeArguments:[s]});const r=await this.connection.devInspectTransactionBlock({transactionBlock:n,sender:S.encode(new Uint8Array(32))});if(!r.results||r.results.length==0||!((a=r.results[0])!=null&&a.returnValues)||((o=r.results[0])==null?void 0:o.returnValues.length)!==1)throw Error("swap rate not set");return G.decode(new Uint8Array(r.results[0].returnValues[0][0].toReversed()))}async getRegisteredTokens(){const t=(await this.getFields()).registered_tokens.fields.id.id;return(await this.connection.getDynamicFields({parentId:t})).data.map(e=>{const{address:a,module:o,name:s}=ye(e.objectType);return new O([a,o,s].join(me))})}async isRegisteredToken(t){const e=new O(I(t)?j.nativeTokenId(this.network,this.chain).address:t).unwrap();try{return await this.getTokenInfo(e)!==null}catch(a){console.error(a)}return!1}async getTokenInfo(t){var e;const a=await this.getFields(),o=new O(a.registered_tokens.type).getPackageId(),s=a.registered_tokens.fields.id.id,c=new O(t),i=X(K,c.unwrap())?K:c.getCoinType();try{const n=await this.connection.getDynamicFieldObject({parentId:s,name:{type:`${o}::registered_tokens::Key<${i}>`,value:{dummy_field:!1}}});if(n.error)throw new Error("Failed to get token info: "+JSON.stringify(n.error));if(!n.data||!n.data.content)throw new Error("Failed to get token info: "+JSON.stringify(n));const{content:r}=n.data;return v(r)&&v(r.fields.value)?r.fields.value.fields:null}catch(n){if((n==null?void 0:n.code)===-32e3&&(e=n.message)!=null&&e.includes("RPC Error"))return console.error(n),null;throw n}}async getFields(){if(!this.fields){const t=await F(this.connection,this.tokenBridgeRelayerObjectId);if(t===null)throw new Error("Failed to get fields from token bridge relayer state");this.fields=t}return this.fields}async getPackageId(){const t=await this.getFields();return new O(t.registered_tokens.type).getPackageId()}async getPackageIds(){const[t,e]=await Promise.all([x(this.connection,this.coreBridgeObjectId),x(this.connection,this.tokenBridgeObjectId)]);return{coreBridge:t,tokenBridge:e}}createUnsignedTx(t,e,a=!1){return new Z(t,this.network,this.chain,e,a)}}L("Sui","TokenBridge",q);L("Sui","AutomaticTokenBridge",J);export{J as SuiAutomaticTokenBridge,q as SuiTokenBridge,U as getTokenCoinType,Q as getTokenFromTokenRegistry};
