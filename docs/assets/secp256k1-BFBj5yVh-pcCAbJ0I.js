import{U as le,Q as de,K as ge,H as Qt,N as we,I as $t,G as vt,P as pe,F as At,J as ye,L as W}from"./solana-CIjJKPC4-DDalIXxg.js";import"./index-BGLdF6jF.js";import"./util--bw7gFPs-CFDtl-lf.js";import"./wallets-B2tqS5lZ-CMHWyddi.js";import"./signer-CinqaaXD-CK79ZFw-.js";import"./index-CNWcuxPc-C5KIuBWR.js";import"./index.es-CEy-pF4C-DURb_lgF.js";function me(r,e,t,n){if(typeof r.setBigUint64=="function")return r.setBigUint64(e,t,n);const o=BigInt(32),f=BigInt(4294967295),i=Number(t>>o&f),c=Number(t&f),s=n?4:0,a=n?0:4;r.setUint32(e+s,i,n),r.setUint32(e+a,c,n)}function Ee(r,e,t){return r&e^~r&t}function be(r,e,t){return r&e^r&t^e&t}class Be extends Qt{constructor(e,t,n,o){super(),this.blockLen=e,this.outputLen=t,this.padOffset=n,this.isLE=o,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=At(this.buffer)}update(e){vt(this);const{view:t,buffer:n,blockLen:o}=this;e=$t(e);const f=e.length;for(let i=0;i<f;){const c=Math.min(o-this.pos,f-i);if(c===o){const s=At(e);for(;o<=f-i;i+=o)this.process(s,i);continue}n.set(e.subarray(i,i+c),this.pos),this.pos+=c,i+=c,this.pos===o&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){vt(this),ye(e,this),this.finished=!0;const{buffer:t,view:n,blockLen:o,isLE:f}=this;let{pos:i}=this;t[i++]=128,this.buffer.subarray(i).fill(0),this.padOffset>o-i&&(this.process(n,0),i=0);for(let w=i;w<o;w++)t[w]=0;me(n,o-8,BigInt(this.length*8),f),this.process(n,0);const c=At(e),s=this.outputLen;if(s%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const a=s/4,g=this.get();if(a>g.length)throw new Error("_sha2: outputLen bigger than state");for(let w=0;w<a;w++)c.setUint32(4*w,g[w],f)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const n=e.slice(0,t);return this.destroy(),n}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:t,buffer:n,length:o,finished:f,destroyed:i,pos:c}=this;return e.length=o,e.pos=c,e.finished=f,e.destroyed=i,o%t&&e.buffer.set(n),e}}const ve=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),Q=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),$=new Uint32Array(64);class xe extends Be{constructor(){super(64,32,8,!1),this.A=Q[0]|0,this.B=Q[1]|0,this.C=Q[2]|0,this.D=Q[3]|0,this.E=Q[4]|0,this.F=Q[5]|0,this.G=Q[6]|0,this.H=Q[7]|0}get(){const{A:e,B:t,C:n,D:o,E:f,F:i,G:c,H:s}=this;return[e,t,n,o,f,i,c,s]}set(e,t,n,o,f,i,c,s){this.A=e|0,this.B=t|0,this.C=n|0,this.D=o|0,this.E=f|0,this.F=i|0,this.G=c|0,this.H=s|0}process(e,t){for(let w=0;w<16;w++,t+=4)$[w]=e.getUint32(t,!1);for(let w=16;w<64;w++){const h=$[w-15],x=$[w-2],S=W(h,7)^W(h,18)^h>>>3,E=W(x,17)^W(x,19)^x>>>10;$[w]=E+$[w-7]+S+$[w-16]|0}let{A:n,B:o,C:f,D:i,E:c,F:s,G:a,H:g}=this;for(let w=0;w<64;w++){const h=W(c,6)^W(c,11)^W(c,25),x=g+h+Ee(c,s,a)+ve[w]+$[w]|0,S=(W(n,2)^W(n,13)^W(n,22))+be(n,o,f)|0;g=a,a=s,s=c,c=i+x|0,i=f,f=o,o=n,n=x+S|0}n=n+this.A|0,o=o+this.B|0,f=f+this.C|0,i=i+this.D|0,c=c+this.E|0,s=s+this.F|0,a=a+this.G|0,g=g+this.H|0,this.set(n,o,f,i,c,s,a,g)}roundClean(){$.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const Se=ge(()=>new xe);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const xt=BigInt(0),St=BigInt(1),Ie=BigInt(2);function st(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&r.constructor.name==="Uint8Array"}function yt(r){if(!st(r))throw new Error("Uint8Array expected")}function ut(r,e){if(typeof e!="boolean")throw new Error(r+" boolean expected, got "+e)}const Ae=Array.from({length:256},(r,e)=>e.toString(16).padStart(2,"0"));function at(r){yt(r);let e="";for(let t=0;t<r.length;t++)e+=Ae[r[t]];return e}function ct(r){const e=r.toString(16);return e.length&1?"0"+e:e}function kt(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);return r===""?xt:BigInt("0x"+r)}const Y={_0:48,_9:57,A:65,F:70,a:97,f:102};function Dt(r){if(r>=Y._0&&r<=Y._9)return r-Y._0;if(r>=Y.A&&r<=Y.F)return r-(Y.A-10);if(r>=Y.a&&r<=Y.f)return r-(Y.a-10)}function ht(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);const e=r.length,t=e/2;if(e%2)throw new Error("hex string expected, got unpadded hex of length "+e);const n=new Uint8Array(t);for(let o=0,f=0;o<t;o++,f+=2){const i=Dt(r.charCodeAt(f)),c=Dt(r.charCodeAt(f+1));if(i===void 0||c===void 0){const s=r[f]+r[f+1];throw new Error('hex string expected, got non-hex character "'+s+'" at index '+f)}n[o]=i*16+c}return n}function ot(r){return kt(at(r))}function Pt(r){return yt(r),kt(at(Uint8Array.from(r).reverse()))}function lt(r,e){return ht(r.toString(16).padStart(e*2,"0"))}function Zt(r,e){return lt(r,e).reverse()}function Oe(r){return ht(ct(r))}function K(r,e,t){let n;if(typeof e=="string")try{n=ht(e)}catch(f){throw new Error(r+" must be hex string or Uint8Array, cause: "+f)}else if(st(e))n=Uint8Array.from(e);else throw new Error(r+" must be hex string or Uint8Array");const o=n.length;if(typeof t=="number"&&o!==t)throw new Error(r+" of length "+t+" expected, got "+o);return n}function pt(...r){let e=0;for(let n=0;n<r.length;n++){const o=r[n];yt(o),e+=o.length}const t=new Uint8Array(e);for(let n=0,o=0;n<r.length;n++){const f=r[n];t.set(f,o),o+=f.length}return t}function qe(r,e){if(r.length!==e.length)return!1;let t=0;for(let n=0;n<r.length;n++)t|=r[n]^e[n];return t===0}function Ne(r){if(typeof r!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(r))}const Ot=r=>typeof r=="bigint"&&xt<=r;function It(r,e,t){return Ot(r)&&Ot(e)&&Ot(t)&&e<=r&&r<t}function it(r,e,t,n){if(!It(e,t,n))throw new Error("expected valid "+r+": "+t+" <= n < "+n+", got "+e)}function te(r){let e;for(e=0;r>xt;r>>=St,e+=1);return e}function Le(r,e){return r>>BigInt(e)&St}function Re(r,e,t){return r|(t?St:xt)<<BigInt(e)}const jt=r=>(Ie<<BigInt(r-1))-St,qt=r=>new Uint8Array(r),Mt=r=>Uint8Array.from(r);function ee(r,e,t){if(typeof r!="number"||r<2)throw new Error("hashLen must be a number");if(typeof e!="number"||e<2)throw new Error("qByteLen must be a number");if(typeof t!="function")throw new Error("hmacFn must be a function");let n=qt(r),o=qt(r),f=0;const i=()=>{n.fill(1),o.fill(0),f=0},c=(...g)=>t(o,n,...g),s=(g=qt())=>{o=c(Mt([0]),g),n=c(),g.length!==0&&(o=c(Mt([1]),g),n=c())},a=()=>{if(f++>=1e3)throw new Error("drbg: tried 1000 values");let g=0;const w=[];for(;g<e;){n=c();const h=n.slice();w.push(h),g+=n.length}return pt(...w)};return(g,w)=>{i(),s(g);let h;for(;!(h=w(a()));)s();return i(),h}}const He={bigint:r=>typeof r=="bigint",function:r=>typeof r=="function",boolean:r=>typeof r=="boolean",string:r=>typeof r=="string",stringOrUint8Array:r=>typeof r=="string"||st(r),isSafeInteger:r=>Number.isSafeInteger(r),array:r=>Array.isArray(r),field:(r,e)=>e.Fp.isValid(r),hash:r=>typeof r=="function"&&Number.isSafeInteger(r.outputLen)};function mt(r,e,t={}){const n=(o,f,i)=>{const c=He[f];if(typeof c!="function")throw new Error("invalid validator function");const s=r[o];if(!(i&&s===void 0)&&!c(s,r))throw new Error("param "+String(o)+" is invalid. Expected "+f+", got "+s)};for(const[o,f]of Object.entries(e))n(o,f,!1);for(const[o,f]of Object.entries(t))n(o,f,!0);return r}const Fe=()=>{throw new Error("not implemented")};function Ft(r){const e=new WeakMap;return(t,...n)=>{const o=e.get(t);if(o!==void 0)return o;const f=r(t,...n);return e.set(t,f),f}}const Ue=Object.freeze(Object.defineProperty({__proto__:null,aInRange:it,abool:ut,abytes:yt,bitGet:Le,bitLen:te,bitMask:jt,bitSet:Re,bytesToHex:at,bytesToNumberBE:ot,bytesToNumberLE:Pt,concatBytes:pt,createHmacDrbg:ee,ensureBytes:K,equalBytes:qe,hexToBytes:ht,hexToNumber:kt,inRange:It,isBytes:st,memoized:Ft,notImplemented:Fe,numberToBytesBE:lt,numberToBytesLE:Zt,numberToHexUnpadded:ct,numberToVarBytesBE:Oe,utf8ToBytes:Ne,validateObject:mt},Symbol.toStringTag,{value:"Module"}));class re extends Qt{constructor(e,t){super(),this.finished=!1,this.destroyed=!1,we(e);const n=$t(t);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const o=this.blockLen,f=new Uint8Array(o);f.set(n.length>o?e.create().update(n).digest():n);for(let i=0;i<f.length;i++)f[i]^=54;this.iHash.update(f),this.oHash=e.create();for(let i=0;i<f.length;i++)f[i]^=106;this.oHash.update(f),f.fill(0)}update(e){return vt(this),this.iHash.update(e),this}digestInto(e){vt(this),pe(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:t,iHash:n,finished:o,destroyed:f,blockLen:i,outputLen:c}=this;return e=e,e.finished=o,e.destroyed=f,e.blockLen=i,e.outputLen=c,e.oHash=t._cloneInto(e.oHash),e.iHash=n._cloneInto(e.iHash),e}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const ne=(r,e,t)=>new re(r,e).update(t).digest();ne.create=(r,e)=>new re(r,e);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const T=BigInt(0),U=BigInt(1),nt=BigInt(2),ze=BigInt(3),Ut=BigInt(4),Kt=BigInt(5),Gt=BigInt(8);function P(r,e){const t=r%e;return t>=T?t:e+t}function Te(r,e,t){if(e<T)throw new Error("invalid exponent, negatives unsupported");if(t<=T)throw new Error("invalid modulus");if(t===U)return T;let n=U;for(;e>T;)e&U&&(n=n*r%t),r=r*r%t,e>>=U;return n}function V(r,e,t){let n=r;for(;e-- >T;)n*=n,n%=t;return n}function zt(r,e){if(r===T)throw new Error("invert: expected non-zero number");if(e<=T)throw new Error("invert: expected positive modulus, got "+e);let t=P(r,e),n=e,o=T,f=U;for(;t!==T;){const i=n/t,c=n%t,s=o-f*i;n=t,t=c,o=f,f=s}if(n!==U)throw new Error("invert: does not exist");return P(o,e)}function Ce(r){const e=(r-U)/nt;let t,n,o;for(t=r-U,n=0;t%nt===T;t/=nt,n++);for(o=nt;o<r&&Te(o,e,r)!==r-U;o++)if(o>1e3)throw new Error("Cannot find square root: likely non-prime P");if(n===1){const i=(r+U)/Ut;return function(c,s){const a=c.pow(s,i);if(!c.eql(c.sqr(a),s))throw new Error("Cannot find square root");return a}}const f=(t+U)/nt;return function(i,c){if(i.pow(c,e)===i.neg(i.ONE))throw new Error("Cannot find square root");let s=n,a=i.pow(i.mul(i.ONE,o),t),g=i.pow(c,f),w=i.pow(c,t);for(;!i.eql(w,i.ONE);){if(i.eql(w,i.ZERO))return i.ZERO;let h=1;for(let S=i.sqr(w);h<s&&!i.eql(S,i.ONE);h++)S=i.sqr(S);const x=i.pow(a,U<<BigInt(s-h-1));a=i.sqr(x),g=i.mul(g,x),w=i.mul(w,a),s=h}return g}}function ke(r){if(r%Ut===ze){const e=(r+U)/Ut;return function(t,n){const o=t.pow(n,e);if(!t.eql(t.sqr(o),n))throw new Error("Cannot find square root");return o}}if(r%Gt===Kt){const e=(r-Kt)/Gt;return function(t,n){const o=t.mul(n,nt),f=t.pow(o,e),i=t.mul(n,f),c=t.mul(t.mul(i,nt),f),s=t.mul(i,t.sub(c,t.ONE));if(!t.eql(t.sqr(s),n))throw new Error("Cannot find square root");return s}}return Ce(r)}const Pe=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Ze(r){const e={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},t=Pe.reduce((n,o)=>(n[o]="function",n),e);return mt(r,t)}function je(r,e,t){if(t<T)throw new Error("invalid exponent, negatives unsupported");if(t===T)return r.ONE;if(t===U)return e;let n=r.ONE,o=e;for(;t>T;)t&U&&(n=r.mul(n,o)),o=r.sqr(o),t>>=U;return n}function Ve(r,e){const t=new Array(e.length),n=e.reduce((f,i,c)=>r.is0(i)?f:(t[c]=f,r.mul(f,i)),r.ONE),o=r.inv(n);return e.reduceRight((f,i,c)=>r.is0(i)?f:(t[c]=r.mul(f,t[c]),r.mul(f,i)),o),t}function oe(r,e){const t=e!==void 0?e:r.toString(2).length,n=Math.ceil(t/8);return{nBitLength:t,nByteLength:n}}function ie(r,e,t=!1,n={}){if(r<=T)throw new Error("invalid field: expected ORDER > 0, got "+r);const{nBitLength:o,nByteLength:f}=oe(r,e);if(f>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let i;const c=Object.freeze({ORDER:r,isLE:t,BITS:o,BYTES:f,MASK:jt(o),ZERO:T,ONE:U,create:s=>P(s,r),isValid:s=>{if(typeof s!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof s);return T<=s&&s<r},is0:s=>s===T,isOdd:s=>(s&U)===U,neg:s=>P(-s,r),eql:(s,a)=>s===a,sqr:s=>P(s*s,r),add:(s,a)=>P(s+a,r),sub:(s,a)=>P(s-a,r),mul:(s,a)=>P(s*a,r),pow:(s,a)=>je(c,s,a),div:(s,a)=>P(s*zt(a,r),r),sqrN:s=>s*s,addN:(s,a)=>s+a,subN:(s,a)=>s-a,mulN:(s,a)=>s*a,inv:s=>zt(s,r),sqrt:n.sqrt||(s=>(i||(i=ke(r)),i(c,s))),invertBatch:s=>Ve(c,s),cmov:(s,a,g)=>g?a:s,toBytes:s=>t?Zt(s,f):lt(s,f),fromBytes:s=>{if(s.length!==f)throw new Error("Field.fromBytes: expected "+f+" bytes, got "+s.length);return t?Pt(s):ot(s)}});return Object.freeze(c)}function se(r){if(typeof r!="bigint")throw new Error("field order must be bigint");const e=r.toString(2).length;return Math.ceil(e/8)}function fe(r){const e=se(r);return e+Math.ceil(e/2)}function De(r,e,t=!1){const n=r.length,o=se(e),f=fe(e);if(n<16||n<f||n>1024)throw new Error("expected "+f+"-1024 bytes of input, got "+n);const i=t?Pt(r):ot(r),c=P(i,e-U)+U;return t?Zt(c,o):lt(c,o)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Wt=BigInt(0),Bt=BigInt(1);function Nt(r,e){const t=e.negate();return r?t:e}function ce(r,e){if(!Number.isSafeInteger(r)||r<=0||r>e)throw new Error("invalid window size, expected [1.."+e+"], got W="+r)}function Lt(r,e){ce(r,e);const t=Math.ceil(e/r)+1,n=2**(r-1);return{windows:t,windowSize:n}}function Me(r,e){if(!Array.isArray(r))throw new Error("array expected");r.forEach((t,n)=>{if(!(t instanceof e))throw new Error("invalid point at index "+n)})}function Ke(r,e){if(!Array.isArray(r))throw new Error("array of scalars expected");r.forEach((t,n)=>{if(!e.isValid(t))throw new Error("invalid scalar at index "+n)})}const Rt=new WeakMap,ue=new WeakMap;function Ht(r){return ue.get(r)||1}function Ge(r,e){return{constTimeNegate:Nt,hasPrecomputes(t){return Ht(t)!==1},unsafeLadder(t,n,o=r.ZERO){let f=t;for(;n>Wt;)n&Bt&&(o=o.add(f)),f=f.double(),n>>=Bt;return o},precomputeWindow(t,n){const{windows:o,windowSize:f}=Lt(n,e),i=[];let c=t,s=c;for(let a=0;a<o;a++){s=c,i.push(s);for(let g=1;g<f;g++)s=s.add(c),i.push(s);c=s.double()}return i},wNAF(t,n,o){const{windows:f,windowSize:i}=Lt(t,e);let c=r.ZERO,s=r.BASE;const a=BigInt(2**t-1),g=2**t,w=BigInt(t);for(let h=0;h<f;h++){const x=h*i;let S=Number(o&a);o>>=w,S>i&&(S-=g,o+=Bt);const E=x,u=x+Math.abs(S)-1,d=h%2!==0,m=S<0;S===0?s=s.add(Nt(d,n[E])):c=c.add(Nt(m,n[u]))}return{p:c,f:s}},wNAFUnsafe(t,n,o,f=r.ZERO){const{windows:i,windowSize:c}=Lt(t,e),s=BigInt(2**t-1),a=2**t,g=BigInt(t);for(let w=0;w<i;w++){const h=w*c;if(o===Wt)break;let x=Number(o&s);if(o>>=g,x>c&&(x-=a,o+=Bt),x===0)continue;let S=n[h+Math.abs(x)-1];x<0&&(S=S.negate()),f=f.add(S)}return f},getPrecomputes(t,n,o){let f=Rt.get(n);return f||(f=this.precomputeWindow(n,t),t!==1&&Rt.set(n,o(f))),f},wNAFCached(t,n,o){const f=Ht(t);return this.wNAF(f,this.getPrecomputes(f,t,o),n)},wNAFCachedUnsafe(t,n,o,f){const i=Ht(t);return i===1?this.unsafeLadder(t,n,f):this.wNAFUnsafe(i,this.getPrecomputes(i,t,o),n,f)},setWindowSize(t,n){ce(n,e),ue.set(t,n),Rt.delete(t)}}}function We(r,e,t,n){if(Me(t,r),Ke(n,e),t.length!==n.length)throw new Error("arrays of points and scalars must have equal length");const o=r.ZERO,f=te(BigInt(t.length)),i=f>12?f-3:f>4?f-2:f?2:1,c=(1<<i)-1,s=new Array(c+1).fill(o),a=Math.floor((e.BITS-1)/i)*i;let g=o;for(let w=a;w>=0;w-=i){s.fill(o);for(let x=0;x<n.length;x++){const S=n[x],E=Number(S>>BigInt(w)&BigInt(c));s[E]=s[E].add(t[x])}let h=o;for(let x=s.length-1,S=o;x>0;x--)S=S.add(s[x]),h=h.add(S);if(g=g.add(h),w!==0)for(let x=0;x<i;x++)g=g.double()}return g}function ae(r){return Ze(r.Fp),mt(r,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...oe(r.n,r.nBitLength),...r,p:r.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Yt(r){r.lowS!==void 0&&ut("lowS",r.lowS),r.prehash!==void 0&&ut("prehash",r.prehash)}function Ye(r){const e=ae(r);mt(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:t,Fp:n,a:o}=e;if(t){if(!n.eql(o,n.ZERO))throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");if(typeof t!="object"||typeof t.beta!="bigint"||typeof t.splitScalar!="function")throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function")}return Object.freeze({...e})}const{bytesToNumberBE:_e,hexToBytes:Xe}=Ue;class Je extends Error{constructor(e=""){super(e)}}const _={Err:Je,_tlv:{encode:(r,e)=>{const{Err:t}=_;if(r<0||r>256)throw new t("tlv.encode: wrong tag");if(e.length&1)throw new t("tlv.encode: unpadded data");const n=e.length/2,o=ct(n);if(o.length/2&128)throw new t("tlv.encode: long form length too big");const f=n>127?ct(o.length/2|128):"";return ct(r)+f+o+e},decode(r,e){const{Err:t}=_;let n=0;if(r<0||r>256)throw new t("tlv.encode: wrong tag");if(e.length<2||e[n++]!==r)throw new t("tlv.decode: wrong tlv");const o=e[n++],f=!!(o&128);let i=0;if(!f)i=o;else{const s=o&127;if(!s)throw new t("tlv.decode(long): indefinite length not supported");if(s>4)throw new t("tlv.decode(long): byte length is too big");const a=e.subarray(n,n+s);if(a.length!==s)throw new t("tlv.decode: length bytes not complete");if(a[0]===0)throw new t("tlv.decode(long): zero leftmost byte");for(const g of a)i=i<<8|g;if(n+=s,i<128)throw new t("tlv.decode(long): not minimal encoding")}const c=e.subarray(n,n+i);if(c.length!==i)throw new t("tlv.decode: wrong value length");return{v:c,l:e.subarray(n+i)}}},_int:{encode(r){const{Err:e}=_;if(r<X)throw new e("integer: negative integers are not allowed");let t=ct(r);if(Number.parseInt(t[0],16)&8&&(t="00"+t),t.length&1)throw new e("unexpected DER parsing assertion: unpadded hex");return t},decode(r){const{Err:e}=_;if(r[0]&128)throw new e("invalid signature integer: negative");if(r[0]===0&&!(r[1]&128))throw new e("invalid signature integer: unnecessary leading zero");return _e(r)}},toSig(r){const{Err:e,_int:t,_tlv:n}=_,o=typeof r=="string"?Xe(r):r;yt(o);const{v:f,l:i}=n.decode(48,o);if(i.length)throw new e("invalid signature: left bytes after parsing");const{v:c,l:s}=n.decode(2,f),{v:a,l:g}=n.decode(2,s);if(g.length)throw new e("invalid signature: left bytes after parsing");return{r:t.decode(c),s:t.decode(a)}},hexFromSig(r){const{_tlv:e,_int:t}=_,n=e.encode(2,t.encode(r.r)),o=e.encode(2,t.encode(r.s)),f=n+o;return e.encode(48,f)}},X=BigInt(0),z=BigInt(1);BigInt(2);const _t=BigInt(3);BigInt(4);function Qe(r){const e=Ye(r),{Fp:t}=e,n=ie(e.n,e.nBitLength),o=e.toBytes||((E,u,d)=>{const m=u.toAffine();return pt(Uint8Array.from([4]),t.toBytes(m.x),t.toBytes(m.y))}),f=e.fromBytes||(E=>{const u=E.subarray(1),d=t.fromBytes(u.subarray(0,t.BYTES)),m=t.fromBytes(u.subarray(t.BYTES,2*t.BYTES));return{x:d,y:m}});function i(E){const{a:u,b:d}=e,m=t.sqr(E),b=t.mul(m,E);return t.add(t.add(b,t.mul(E,u)),d)}if(!t.eql(t.sqr(e.Gy),i(e.Gx)))throw new Error("bad generator point: equation left != right");function c(E){return It(E,z,e.n)}function s(E){const{allowedPrivateKeyLengths:u,nByteLength:d,wrapPrivateKey:m,n:b}=e;if(u&&typeof E!="bigint"){if(st(E)&&(E=at(E)),typeof E!="string"||!u.includes(E.length))throw new Error("invalid private key");E=E.padStart(d*2,"0")}let q;try{q=typeof E=="bigint"?E:ot(K("private key",E,d))}catch{throw new Error("invalid private key, expected hex or "+d+" bytes, got "+typeof E)}return m&&(q=P(q,b)),it("private key",q,z,b),q}function a(E){if(!(E instanceof h))throw new Error("ProjectivePoint expected")}const g=Ft((E,u)=>{const{px:d,py:m,pz:b}=E;if(t.eql(b,t.ONE))return{x:d,y:m};const q=E.is0();u==null&&(u=q?t.ONE:t.inv(b));const L=t.mul(d,u),O=t.mul(m,u),B=t.mul(b,u);if(q)return{x:t.ZERO,y:t.ZERO};if(!t.eql(B,t.ONE))throw new Error("invZ was invalid");return{x:L,y:O}}),w=Ft(E=>{if(E.is0()){if(e.allowInfinityPoint&&!t.is0(E.py))return;throw new Error("bad point: ZERO")}const{x:u,y:d}=E.toAffine();if(!t.isValid(u)||!t.isValid(d))throw new Error("bad point: x or y not FE");const m=t.sqr(d),b=i(u);if(!t.eql(m,b))throw new Error("bad point: equation left != right");if(!E.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class h{constructor(u,d,m){if(this.px=u,this.py=d,this.pz=m,u==null||!t.isValid(u))throw new Error("x required");if(d==null||!t.isValid(d))throw new Error("y required");if(m==null||!t.isValid(m))throw new Error("z required");Object.freeze(this)}static fromAffine(u){const{x:d,y:m}=u||{};if(!u||!t.isValid(d)||!t.isValid(m))throw new Error("invalid affine point");if(u instanceof h)throw new Error("projective point not allowed");const b=q=>t.eql(q,t.ZERO);return b(d)&&b(m)?h.ZERO:new h(d,m,t.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(u){const d=t.invertBatch(u.map(m=>m.pz));return u.map((m,b)=>m.toAffine(d[b])).map(h.fromAffine)}static fromHex(u){const d=h.fromAffine(f(K("pointHex",u)));return d.assertValidity(),d}static fromPrivateKey(u){return h.BASE.multiply(s(u))}static msm(u,d){return We(h,n,u,d)}_setWindowSize(u){S.setWindowSize(this,u)}assertValidity(){w(this)}hasEvenY(){const{y:u}=this.toAffine();if(t.isOdd)return!t.isOdd(u);throw new Error("Field doesn't support isOdd")}equals(u){a(u);const{px:d,py:m,pz:b}=this,{px:q,py:L,pz:O}=u,B=t.eql(t.mul(d,O),t.mul(q,b)),I=t.eql(t.mul(m,O),t.mul(L,b));return B&&I}negate(){return new h(this.px,t.neg(this.py),this.pz)}double(){const{a:u,b:d}=e,m=t.mul(d,_t),{px:b,py:q,pz:L}=this;let O=t.ZERO,B=t.ZERO,I=t.ZERO,v=t.mul(b,b),C=t.mul(q,q),H=t.mul(L,L),R=t.mul(b,q);return R=t.add(R,R),I=t.mul(b,L),I=t.add(I,I),O=t.mul(u,I),B=t.mul(m,H),B=t.add(O,B),O=t.sub(C,B),B=t.add(C,B),B=t.mul(O,B),O=t.mul(R,O),I=t.mul(m,I),H=t.mul(u,H),R=t.sub(v,H),R=t.mul(u,R),R=t.add(R,I),I=t.add(v,v),v=t.add(I,v),v=t.add(v,H),v=t.mul(v,R),B=t.add(B,v),H=t.mul(q,L),H=t.add(H,H),v=t.mul(H,R),O=t.sub(O,v),I=t.mul(H,C),I=t.add(I,I),I=t.add(I,I),new h(O,B,I)}add(u){a(u);const{px:d,py:m,pz:b}=this,{px:q,py:L,pz:O}=u;let B=t.ZERO,I=t.ZERO,v=t.ZERO;const C=e.a,H=t.mul(e.b,_t);let R=t.mul(d,q),Z=t.mul(m,L),l=t.mul(b,O),p=t.add(d,m),y=t.add(q,L);p=t.mul(p,y),y=t.add(R,Z),p=t.sub(p,y),y=t.add(d,b);let A=t.add(q,O);return y=t.mul(y,A),A=t.add(R,l),y=t.sub(y,A),A=t.add(m,b),B=t.add(L,O),A=t.mul(A,B),B=t.add(Z,l),A=t.sub(A,B),v=t.mul(C,y),B=t.mul(H,l),v=t.add(B,v),B=t.sub(Z,v),v=t.add(Z,v),I=t.mul(B,v),Z=t.add(R,R),Z=t.add(Z,R),l=t.mul(C,l),y=t.mul(H,y),Z=t.add(Z,l),l=t.sub(R,l),l=t.mul(C,l),y=t.add(y,l),R=t.mul(Z,y),I=t.add(I,R),R=t.mul(A,y),B=t.mul(p,B),B=t.sub(B,R),R=t.mul(p,Z),v=t.mul(A,v),v=t.add(v,R),new h(B,I,v)}subtract(u){return this.add(u.negate())}is0(){return this.equals(h.ZERO)}wNAF(u){return S.wNAFCached(this,u,h.normalizeZ)}multiplyUnsafe(u){const{endo:d,n:m}=e;it("scalar",u,X,m);const b=h.ZERO;if(u===X)return b;if(this.is0()||u===z)return this;if(!d||S.hasPrecomputes(this))return S.wNAFCachedUnsafe(this,u,h.normalizeZ);let{k1neg:q,k1:L,k2neg:O,k2:B}=d.splitScalar(u),I=b,v=b,C=this;for(;L>X||B>X;)L&z&&(I=I.add(C)),B&z&&(v=v.add(C)),C=C.double(),L>>=z,B>>=z;return q&&(I=I.negate()),O&&(v=v.negate()),v=new h(t.mul(v.px,d.beta),v.py,v.pz),I.add(v)}multiply(u){const{endo:d,n:m}=e;it("scalar",u,z,m);let b,q;if(d){const{k1neg:L,k1:O,k2neg:B,k2:I}=d.splitScalar(u);let{p:v,f:C}=this.wNAF(O),{p:H,f:R}=this.wNAF(I);v=S.constTimeNegate(L,v),H=S.constTimeNegate(B,H),H=new h(t.mul(H.px,d.beta),H.py,H.pz),b=v.add(H),q=C.add(R)}else{const{p:L,f:O}=this.wNAF(u);b=L,q=O}return h.normalizeZ([b,q])[0]}multiplyAndAddUnsafe(u,d,m){const b=h.BASE,q=(O,B)=>B===X||B===z||!O.equals(b)?O.multiplyUnsafe(B):O.multiply(B),L=q(this,d).add(q(u,m));return L.is0()?void 0:L}toAffine(u){return g(this,u)}isTorsionFree(){const{h:u,isTorsionFree:d}=e;if(u===z)return!0;if(d)return d(h,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:u,clearCofactor:d}=e;return u===z?this:d?d(h,this):this.multiplyUnsafe(e.h)}toRawBytes(u=!0){return ut("isCompressed",u),this.assertValidity(),o(h,this,u)}toHex(u=!0){return ut("isCompressed",u),at(this.toRawBytes(u))}}h.BASE=new h(e.Gx,e.Gy,t.ONE),h.ZERO=new h(t.ZERO,t.ONE,t.ZERO);const x=e.nBitLength,S=Ge(h,e.endo?Math.ceil(x/2):x);return{CURVE:e,ProjectivePoint:h,normPrivateKeyToScalar:s,weierstrassEquation:i,isWithinCurveOrder:c}}function $e(r){const e=ae(r);return mt(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}function tr(r){const e=$e(r),{Fp:t,n}=e,o=t.BYTES+1,f=2*t.BYTES+1;function i(l){return P(l,n)}function c(l){return zt(l,n)}const{ProjectivePoint:s,normPrivateKeyToScalar:a,weierstrassEquation:g,isWithinCurveOrder:w}=Qe({...e,toBytes(l,p,y){const A=p.toAffine(),F=t.toBytes(A.x),N=pt;return ut("isCompressed",y),y?N(Uint8Array.from([p.hasEvenY()?2:3]),F):N(Uint8Array.from([4]),F,t.toBytes(A.y))},fromBytes(l){const p=l.length,y=l[0],A=l.subarray(1);if(p===o&&(y===2||y===3)){const F=ot(A);if(!It(F,z,t.ORDER))throw new Error("Point is not on curve");const N=g(F);let j;try{j=t.sqrt(N)}catch(k){const D=k instanceof Error?": "+k.message:"";throw new Error("Point is not on curve"+D)}const G=(j&z)===z;return(y&1)===1!==G&&(j=t.neg(j)),{x:F,y:j}}else if(p===f&&y===4){const F=t.fromBytes(A.subarray(0,t.BYTES)),N=t.fromBytes(A.subarray(t.BYTES,2*t.BYTES));return{x:F,y:N}}else{const F=o,N=f;throw new Error("invalid Point, expected length of "+F+", or uncompressed "+N+", got "+p)}}}),h=l=>at(lt(l,e.nByteLength));function x(l){const p=n>>z;return l>p}function S(l){return x(l)?i(-l):l}const E=(l,p,y)=>ot(l.slice(p,y));class u{constructor(p,y,A){this.r=p,this.s=y,this.recovery=A,this.assertValidity()}static fromCompact(p){const y=e.nByteLength;return p=K("compactSignature",p,y*2),new u(E(p,0,y),E(p,y,2*y))}static fromDER(p){const{r:y,s:A}=_.toSig(K("DER",p));return new u(y,A)}assertValidity(){it("r",this.r,z,n),it("s",this.s,z,n)}addRecoveryBit(p){return new u(this.r,this.s,p)}recoverPublicKey(p){const{r:y,s:A,recovery:F}=this,N=O(K("msgHash",p));if(F==null||![0,1,2,3].includes(F))throw new Error("recovery id invalid");const j=F===2||F===3?y+e.n:y;if(j>=t.ORDER)throw new Error("recovery id 2 or 3 invalid");const G=F&1?"03":"02",k=s.fromHex(G+h(j)),D=c(j),tt=i(-N*D),M=i(A*D),J=s.BASE.multiplyAndAddUnsafe(k,tt,M);if(!J)throw new Error("point at infinify");return J.assertValidity(),J}hasHighS(){return x(this.s)}normalizeS(){return this.hasHighS()?new u(this.r,i(-this.s),this.recovery):this}toDERRawBytes(){return ht(this.toDERHex())}toDERHex(){return _.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return ht(this.toCompactHex())}toCompactHex(){return h(this.r)+h(this.s)}}const d={isValidPrivateKey(l){try{return a(l),!0}catch{return!1}},normPrivateKeyToScalar:a,randomPrivateKey:()=>{const l=fe(e.n);return De(e.randomBytes(l),e.n)},precompute(l=8,p=s.BASE){return p._setWindowSize(l),p.multiply(BigInt(3)),p}};function m(l,p=!0){return s.fromPrivateKey(l).toRawBytes(p)}function b(l){const p=st(l),y=typeof l=="string",A=(p||y)&&l.length;return p?A===o||A===f:y?A===2*o||A===2*f:l instanceof s}function q(l,p,y=!0){if(b(l))throw new Error("first arg must be private key");if(!b(p))throw new Error("second arg must be public key");return s.fromHex(p).multiply(a(l)).toRawBytes(y)}const L=e.bits2int||function(l){if(l.length>8192)throw new Error("input is too large");const p=ot(l),y=l.length*8-e.nBitLength;return y>0?p>>BigInt(y):p},O=e.bits2int_modN||function(l){return i(L(l))},B=jt(e.nBitLength);function I(l){return it("num < 2^"+e.nBitLength,l,X,B),lt(l,e.nByteLength)}function v(l,p,y=C){if(["recovered","canonical"].some(et=>et in y))throw new Error("sign() legacy options not supported");const{hash:A,randomBytes:F}=e;let{lowS:N,prehash:j,extraEntropy:G}=y;N==null&&(N=!0),l=K("msgHash",l),Yt(y),j&&(l=K("prehashed msgHash",A(l)));const k=O(l),D=a(p),tt=[I(D),I(k)];if(G!=null&&G!==!1){const et=G===!0?F(t.BYTES):G;tt.push(K("extraEntropy",et))}const M=pt(...tt),J=k;function Et(et){const dt=L(et);if(!w(dt))return;const bt=c(dt),gt=s.BASE.multiply(dt).toAffine(),ft=i(gt.x);if(ft===X)return;const rt=i(bt*i(J+ft*D));if(rt===X)return;let wt=(gt.x===ft?0:2)|Number(gt.y&z),Vt=rt;return N&&x(rt)&&(Vt=S(rt),wt^=1),new u(ft,Vt,wt)}return{seed:M,k2sig:Et}}const C={lowS:e.lowS,prehash:!1},H={lowS:e.lowS,prehash:!1};function R(l,p,y=C){const{seed:A,k2sig:F}=v(l,p,y),N=e;return ee(N.hash.outputLen,N.nByteLength,N.hmac)(A,F)}s.BASE._setWindowSize(8);function Z(l,p,y,A=H){var F;const N=l;p=K("msgHash",p),y=K("publicKey",y);const{lowS:j,prehash:G,format:k}=A;if(Yt(A),"strict"in A)throw new Error("options.strict was renamed to lowS");if(k!==void 0&&k!=="compact"&&k!=="der")throw new Error("format must be compact or der");const D=typeof N=="string"||st(N),tt=!D&&!k&&typeof N=="object"&&N!==null&&typeof N.r=="bigint"&&typeof N.s=="bigint";if(!D&&!tt)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let M,J;try{if(tt&&(M=new u(N.r,N.s)),D){try{k!=="compact"&&(M=u.fromDER(N))}catch(wt){if(!(wt instanceof _.Err))throw wt}!M&&k!=="der"&&(M=u.fromCompact(N))}J=s.fromHex(y)}catch{return!1}if(!M||j&&M.hasHighS())return!1;G&&(p=e.hash(p));const{r:Et,s:et}=M,dt=O(p),bt=c(et),gt=i(dt*bt),ft=i(Et*bt),rt=(F=s.BASE.multiplyAndAddUnsafe(J,gt,ft))==null?void 0:F.toAffine();return rt?i(rt.x)===Et:!1}return{CURVE:e,getPublicKey:m,getSharedSecret:q,sign:R,verify:Z,ProjectivePoint:s,Signature:u,utils:d}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function er(r){return{hash:r,hmac:(e,...t)=>ne(r,e,le(...t)),randomBytes:de}}function rr(r,e){const t=n=>tr({...r,...er(n)});return{...t(e),create:t}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const he=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),Xt=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),nr=BigInt(1),Tt=BigInt(2),Jt=(r,e)=>(r+e/Tt)/e;function or(r){const e=he,t=BigInt(3),n=BigInt(6),o=BigInt(11),f=BigInt(22),i=BigInt(23),c=BigInt(44),s=BigInt(88),a=r*r*r%e,g=a*a*r%e,w=V(g,t,e)*g%e,h=V(w,t,e)*g%e,x=V(h,Tt,e)*a%e,S=V(x,o,e)*x%e,E=V(S,f,e)*S%e,u=V(E,c,e)*E%e,d=V(u,s,e)*u%e,m=V(d,c,e)*E%e,b=V(m,t,e)*g%e,q=V(b,i,e)*S%e,L=V(q,n,e)*a%e,O=V(L,Tt,e);if(!Ct.eql(Ct.sqr(O),r))throw new Error("Cannot find square root");return O}const Ct=ie(he,void 0,void 0,{sqrt:or}),ir=rr({a:BigInt(0),b:BigInt(7),Fp:Ct,n:Xt,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:r=>{const e=Xt,t=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),n=-nr*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),o=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),f=t,i=BigInt("0x100000000000000000000000000000000"),c=Jt(f*r,e),s=Jt(-n*r,e);let a=P(r-c*t-s*o,e),g=P(-c*n-s*f,e);const w=a>i,h=g>i;if(w&&(a=e-a),h&&(g=e-g),a>i||g>i)throw new Error("splitScalar: Endomorphism failed, k="+r);return{k1neg:w,k1:a,k2neg:h,k2:g}}}},Se);BigInt(0);ir.ProjectivePoint;export{ir as secp256k1};
