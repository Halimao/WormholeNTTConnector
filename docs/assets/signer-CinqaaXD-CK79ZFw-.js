import{S as f,aN as P,bm as S,bn as M,bo as E,be as y,bf as K,ab as R,bg as v,bp as T,bq as O}from"./index-BGLdF6jF.js";var W=Object.defineProperty,$=(r,t,e)=>t in r?W(r,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):r[t]=e,m=(r,t,e)=>$(r,typeof t!="symbol"?t+"":t,e);const b=.5,_=1,w=1,k=1e8,F=5,A=25e4;async function H(r,t,e){const[s,i]=await f.chainFromRpc(r),o=typeof t=="string"?P.fromSecretKey(S.decode(t)):t;if(e!=null&&e.priorityFee&&e.priorityFee.percentile&&e.priorityFee.percentile>1)throw new Error("priorityFeePercentile must be a number between 0 and 1");return new I(r,i,o,(e==null?void 0:e.debug)??!1,(e==null?void 0:e.priorityFee)??{},(e==null?void 0:e.retries)??F,e==null?void 0:e.sendOpts)}class I{constructor(t,e,s,i=!1,o,c=F,a){m(this,"_rpc"),m(this,"_chain"),m(this,"_keypair"),m(this,"_debug"),m(this,"_priorityFee"),m(this,"_maxResubmits"),m(this,"_sendOpts"),this._rpc=t,this._chain=e,this._keypair=s,this._debug=i,this._priorityFee=o,this._maxResubmits=c,this._sendOpts=a,this._sendOpts=this._sendOpts??{preflightCommitment:this._rpc.commitment}}chain(){return this._chain}address(){return this._keypair.publicKey.toBase58()}retryable(t){var e;if(t instanceof M)return!0;if(!(t instanceof E)||!t.message.includes("Transaction simulation failed"))return!1;if(t.message.includes("Blockhash not found"))return!0;const s=(e=t.logs)==null?void 0:e.find(i=>i.startsWith("Program log: Error: "));return s?!!(s.includes("Not enough bytes")||s.includes("Unexpected length of input")):!1}async signAndSend(t){var e;let{blockhash:s,lastValidBlockHeight:i}=await f.latestBlock(this._rpc);const o=[];for(const a of t){const{description:u,transaction:{transaction:n,signers:p}}=a;this._debug&&console.log(`Signing: ${u} for ${this.address()}`);let l;(e=this._priorityFee)!=null&&e.percentile&&this._priorityFee.percentile>0&&(l=await V(this._rpc,n,this._priorityFee.percentile,this._priorityFee.percentileMultiple,this._priorityFee.min,this._priorityFee.max)),this._debug&&z(n);for(let h=0;h<this._maxResubmits;h++)try{if(y(n)){if(l&&h===0){const d=K.decompile(n.message);d.instructions.push(...l),n.message=d.compileToV0Message()}n.message.recentBlockhash=s,n.sign([this._keypair,...p??[]])}else l&&h===0&&n.add(...l),n.recentBlockhash=s,n.lastValidBlockHeight=i,n.partialSign(this._keypair,...p??[]);this._debug&&console.log("Submitting transactions ");const{signature:g}=await f.sendTxWithRetry(this._rpc,n.serialize(),this._sendOpts);o.push(g);break}catch(g){if(h===this._maxResubmits-1||!this.retryable(g))throw g;this._debug&&console.log(`Failed to send transaction on attempt ${h}, retrying: `,g);const{blockhash:d,lastValidBlockHeight:x}=await f.latestBlock(this._rpc);i=x,s=d}}this._debug&&console.log("Waiting for confirmation for: ",o);const c=(await Promise.all(o.map(async a=>{try{return await this._rpc.confirmTransaction({signature:a,blockhash:s,lastValidBlockHeight:i},this._rpc.commitment)}catch(u){throw console.error("Failed to confirm transaction: ",u),u}}))).filter(a=>a.value.err).map(a=>a.value.err);if(c.length>0)throw new Error(`Failed to confirm transaction: ${c}`);return o}}function z(r){if(y(r)){console.log(r.signatures);const t=r.message,e=t.getAccountKeys();t.compiledInstructions.forEach(s=>{console.log("Program",e.get(s.programIdIndex).toBase58()),console.log("Data: ",R.encode(s.data)),console.log("Keys: ",s.accountKeyIndexes.map(i=>[i,e.get(i).toBase58()]))})}else console.log(r.signatures),console.log(r.feePayer),r.instructions.forEach(t=>{console.log("Program",t.programId.toBase58()),console.log("Data: ",t.data.toString("hex")),console.log("Keys: ",t.keys.map(e=>[e,e.pubkey.toBase58()]))})}async function V(r,t,e=b,s=_,i=w,o=k){const[c,a]=await Promise.all([C(r,t),L(r,t,e,s,i,o)]);return[v.setComputeUnitLimit({units:c}),v.setComputeUnitPrice({microLamports:a})]}async function C(r,t){var e;let s=A;try{const i=await(y(t),r.simulateTransaction(t));i.value.err&&console.error(`Error simulating Solana transaction: ${i.value.err}`),(e=i==null?void 0:i.value)!=null&&e.unitsConsumed&&(s=Math.round(i.value.unitsConsumed*1.2))}catch(i){console.error(`Failed to calculate compute unit limit for Solana transaction: ${i}`)}return s}async function B(r,t){if(y(t)){const e=(await Promise.all(t.message.addressTableLookups.map(o=>r.getAddressLookupTable(o.accountKey)))).map(o=>o.value).filter(o=>o!==null),s=t.message,i=s.getAccountKeys({addressLookupTableAccounts:e??void 0});return s.compiledInstructions.flatMap(o=>o.accountKeyIndexes).map(o=>s.isAccountWritable(o)?i.get(o):null).filter(Boolean)}else return t.instructions.flatMap(e=>e.keys).map(e=>e.isWritable?e.pubkey:null).filter(Boolean)}async function L(r,t,e=b,s=_,i=w,o=k){let c=i;const a=await B(r,t);try{const u=await r.getRecentPrioritizationFees({lockedWritableAccounts:a});if(u){const n=u.map(l=>l.prioritizationFee).sort((l,h)=>l-h),p=Math.ceil(n.length*e);if(n.length>p){let l=n[p];s>0&&(l*=s),c=Math.max(c,l)}}}catch(u){console.error("Error fetching Solana recent fees",u)}return Math.min(Math.max(c,i),o)}async function D(r,t,e=b,s=_,i=w,o=k){const c=e*1e4;if(c<1||c>1e4)throw new Error("percentile must be between 0.0001 and 1");const a=r._rpcRequest,u=[await B(r,t),{percentile:c}],n=await a("getRecentPrioritizationFees",u);if(n.error)throw new Error(n.error);const p=n.result.map(h=>h.prioritizationFee);if(p.length===0)return i;const l=Math.floor(T(p)*(s>0?s:1));return O(l,i,o)}export{H as Y,D as q,L as v};
