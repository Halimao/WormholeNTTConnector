import{aO as a,cr as H,cs as P,ct as v,cu as j,cv as Q,cw as X,d3 as J,S as _,N as E,d9 as Y,da as ee,db as te,dc as ie,dd as ne,de as W,cG as p,df as re,dg as ae,dh as N,aS as x,aQ as K,di as se,dj as oe,aC as o,dk as de,d8 as ce,cN as me,V as ge,d7 as ue,aU as he}from"./index-BGLdF6jF.js";import{deriveWrappedMetaKey as L,deriveTokenBridgeConfigKey as U,deriveAuthoritySignerKey as pe,deriveSenderAccountKey as ye,deriveEndpointKey as we,deriveMintAuthorityKey as fe}from"./index-B1YHtJKf-B_1PrB0e.js";var ke=Object.defineProperty,Me=(i,t,e)=>t in i?ke(i,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):i[t]=e,m=(i,t,e)=>Me(i,typeof t!="symbol"?t+"":t,e);const Se={version:"0.1.0",name:"wormhole_gateway",instructions:[{name:"initialize",accounts:[{name:"authority",isMut:!0,isSigner:!0},{name:"custodian",isMut:!0,isSigner:!1},{name:"tbtcMint",isMut:!1,isSigner:!1,docs:["TBTC Program's mint PDA address bump is saved in this program's config. Ordinarily, we would","not have to deserialize this account. But we do in this case to make sure the TBTC program","has been initialized before this program."]},{name:"wrappedTbtcMint",isMut:!1,isSigner:!1},{name:"wrappedTbtcToken",isMut:!0,isSigner:!1},{name:"tokenBridgeSender",isMut:!1,isSigner:!1,docs:["sign for transferring via Token Bridge program with a message."]},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[{name:"mintingLimit",type:"u64"}]},{name:"changeAuthority",accounts:[{name:"custodian",isMut:!0,isSigner:!1},{name:"authority",isMut:!1,isSigner:!0},{name:"newAuthority",isMut:!1,isSigner:!1}],args:[]},{name:"cancelAuthorityChange",accounts:[{name:"custodian",isMut:!0,isSigner:!1},{name:"authority",isMut:!1,isSigner:!0}],args:[]},{name:"takeAuthority",accounts:[{name:"custodian",isMut:!0,isSigner:!1},{name:"pendingAuthority",isMut:!1,isSigner:!0}],args:[]},{name:"updateGatewayAddress",accounts:[{name:"custodian",isMut:!1,isSigner:!1},{name:"gatewayInfo",isMut:!0,isSigner:!1},{name:"authority",isMut:!0,isSigner:!0},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[{name:"args",type:{defined:"UpdateGatewayAddressArgs"}}]},{name:"updateMintingLimit",accounts:[{name:"custodian",isMut:!0,isSigner:!1},{name:"authority",isMut:!1,isSigner:!0}],args:[{name:"newLimit",type:"u64"}]},{name:"receiveTbtc",accounts:[{name:"payer",isMut:!0,isSigner:!0},{name:"custodian",isMut:!0,isSigner:!1},{name:"postedVaa",isMut:!1,isSigner:!1},{name:"tokenBridgeClaim",isMut:!0,isSigner:!1,docs:["transfer. By checking whether this account exists is a short-circuit way of bailing out","early if this transfer has already been redeemed (as opposed to letting the Token Bridge","instruction fail)."]},{name:"wrappedTbtcToken",isMut:!0,isSigner:!1,docs:["Custody account."]},{name:"wrappedTbtcMint",isMut:!0,isSigner:!1,docs:["This mint is owned by the Wormhole Token Bridge program. This PDA address is stored in the","custodian account."]},{name:"tbtcMint",isMut:!0,isSigner:!1},{name:"recipientToken",isMut:!0,isSigner:!1,docs:["Token account for minted tBTC.","","NOTE: Because the recipient is encoded in the transfer message payload, we can check the","authority from the deserialized VAA. But we should still check whether the authority is the","zero address in access control."]},{name:"recipient",isMut:!1,isSigner:!1,docs:["be created for him."]},{name:"recipientWrappedToken",isMut:!0,isSigner:!1,docs:["The gateway will create an associated token account for the recipient if it doesn't exist.","","NOTE: When the minting limit increases, the recipient can use this token account to mint","tBTC using the deposit_wormhole_tbtc instruction."]},{name:"tbtcConfig",isMut:!1,isSigner:!1},{name:"tbtcMinterInfo",isMut:!1,isSigner:!1},{name:"tokenBridgeConfig",isMut:!1,isSigner:!1},{name:"tokenBridgeRegisteredEmitter",isMut:!1,isSigner:!1},{name:"tokenBridgeWrappedAsset",isMut:!1,isSigner:!1},{name:"tokenBridgeMintAuthority",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1},{name:"tbtcProgram",isMut:!1,isSigner:!1},{name:"tokenBridgeProgram",isMut:!1,isSigner:!1},{name:"coreBridgeProgram",isMut:!1,isSigner:!1},{name:"associatedTokenProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[{name:"messageHash",type:{array:["u8",32]}}]},{name:"sendTbtcGateway",accounts:[{name:"custodian",isMut:!0,isSigner:!1},{name:"gatewayInfo",isMut:!1,isSigner:!1},{name:"wrappedTbtcToken",isMut:!0,isSigner:!1,docs:["Custody account."]},{name:"wrappedTbtcMint",isMut:!0,isSigner:!1},{name:"tbtcMint",isMut:!0,isSigner:!1},{name:"senderToken",isMut:!0,isSigner:!1},{name:"sender",isMut:!0,isSigner:!0},{name:"tokenBridgeConfig",isMut:!1,isSigner:!1},{name:"tokenBridgeWrappedAsset",isMut:!1,isSigner:!1},{name:"tokenBridgeTransferAuthority",isMut:!1,isSigner:!1},{name:"coreBridgeData",isMut:!0,isSigner:!1},{name:"coreMessage",isMut:!0,isSigner:!1},{name:"tokenBridgeCoreEmitter",isMut:!1,isSigner:!1},{name:"coreEmitterSequence",isMut:!0,isSigner:!1},{name:"coreFeeCollector",isMut:!0,isSigner:!1},{name:"clock",isMut:!1,isSigner:!1},{name:"tokenBridgeSender",isMut:!1,isSigner:!1,docs:["sign for transferring via Token Bridge program with a message."]},{name:"rent",isMut:!1,isSigner:!1},{name:"tokenBridgeProgram",isMut:!1,isSigner:!1},{name:"coreBridgeProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[{name:"args",type:{defined:"SendTbtcGatewayArgs"}}]},{name:"sendTbtcWrapped",accounts:[{name:"custodian",isMut:!0,isSigner:!1},{name:"wrappedTbtcToken",isMut:!0,isSigner:!1,docs:["Custody account."]},{name:"wrappedTbtcMint",isMut:!0,isSigner:!1},{name:"tbtcMint",isMut:!0,isSigner:!1},{name:"senderToken",isMut:!0,isSigner:!1},{name:"sender",isMut:!0,isSigner:!0},{name:"tokenBridgeConfig",isMut:!1,isSigner:!1},{name:"tokenBridgeWrappedAsset",isMut:!1,isSigner:!1},{name:"tokenBridgeTransferAuthority",isMut:!1,isSigner:!1},{name:"coreBridgeData",isMut:!0,isSigner:!1},{name:"coreMessage",isMut:!0,isSigner:!1},{name:"tokenBridgeCoreEmitter",isMut:!1,isSigner:!1},{name:"coreEmitterSequence",isMut:!0,isSigner:!1},{name:"coreFeeCollector",isMut:!0,isSigner:!1},{name:"clock",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1},{name:"tokenBridgeProgram",isMut:!1,isSigner:!1},{name:"coreBridgeProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[{name:"args",type:{defined:"SendTbtcWrappedArgs"}}]},{name:"depositWormholeTbtc",accounts:[{name:"custodian",isMut:!0,isSigner:!1,docs:["NOTE: This account also acts as a minter for the TBTC program."]},{name:"wrappedTbtcToken",isMut:!0,isSigner:!1,docs:["This token account is owned by this program, whose mint is the wrapped TBTC mint. This PDA","address is stored in the custodian account."]},{name:"wrappedTbtcMint",isMut:!1,isSigner:!1,docs:["This mint is owned by the Wormhole Token Bridge program. This PDA address is stored in the","custodian account."]},{name:"tbtcMint",isMut:!0,isSigner:!1,docs:["This mint is owned by the TBTC program. This PDA address is stored in the custodian account."]},{name:"recipientWrappedToken",isMut:!0,isSigner:!1},{name:"recipientToken",isMut:!0,isSigner:!1},{name:"recipient",isMut:!1,isSigner:!0,docs:["This program requires that the owner of the TBTC token account sign for TBTC being minted","into his account."]},{name:"tbtcConfig",isMut:!1,isSigner:!1},{name:"tbtcMinterInfo",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"tbtcProgram",isMut:!1,isSigner:!1}],args:[{name:"amount",type:"u64"}]}],accounts:[{name:"custodian",type:{kind:"struct",fields:[{name:"bump",type:"u8"},{name:"authority",type:"publicKey"},{name:"pendingAuthority",type:{option:"publicKey"}},{name:"tbtcMint",type:"publicKey"},{name:"wrappedTbtcMint",type:"publicKey"},{name:"wrappedTbtcToken",type:"publicKey"},{name:"tokenBridgeSender",type:"publicKey"},{name:"tokenBridgeSenderBump",type:"u8"},{name:"mintingLimit",type:"u64"},{name:"mintedAmount",type:"u64"}]}},{name:"GatewayInfo",type:{kind:"struct",fields:[{name:"bump",type:"u8"},{name:"address",type:{array:["u8",32]}}]}}],types:[{name:"UpdateGatewayAddressArgs",type:{kind:"struct",fields:[{name:"chain",type:"u16"},{name:"address",type:{array:["u8",32]}}]}},{name:"SendTbtcGatewayArgs",type:{kind:"struct",fields:[{name:"amount",type:"u64"},{name:"recipientChain",type:"u16"},{name:"recipient",type:{array:["u8",32]}},{name:"nonce",type:"u32"}]}},{name:"SendTbtcWrappedArgs",type:{kind:"struct",fields:[{name:"amount",type:"u64"},{name:"recipientChain",type:"u16"},{name:"recipient",type:{array:["u8",32]}},{name:"arbiterFee",type:"u64"},{name:"nonce",type:"u32"}]}}],events:[{name:"WormholeTbtcReceived",fields:[{name:"receiver",type:"publicKey",index:!1},{name:"amount",type:"u64",index:!1}]},{name:"WormholeTbtcSent",fields:[{name:"amount",type:"u64",index:!1},{name:"recipientChain",type:"u16",index:!1},{name:"gateway",type:{array:["u8",32]},index:!1},{name:"recipient",type:{array:["u8",32]},index:!1},{name:"arbiterFee",type:"u64",index:!1},{name:"nonce",type:"u32",index:!1}]},{name:"WormholeTbtcDeposited",fields:[{name:"depositor",type:"publicKey",index:!1},{name:"amount",type:"u64",index:!1}]},{name:"GatewayAddressUpdated",fields:[{name:"chain",type:"u16",index:!1},{name:"gateway",type:{array:["u8",32]},index:!1}]},{name:"MintingLimitUpdated",fields:[{name:"mintingLimit",type:"u64",index:!1}]}],errors:[{code:6016,name:"MintingLimitExceeded",msg:"Cannot mint more than the minting limit"},{code:6032,name:"IsNotAuthority",msg:"Only custodian authority is permitted for this action"},{code:6034,name:"IsNotPendingAuthority",msg:"Not valid pending authority to take authority"},{code:6036,name:"NoPendingAuthorityChange",msg:"No pending authority"},{code:6048,name:"ZeroRecipient",msg:"0x0 recipient not allowed"},{code:6064,name:"NotEnoughWrappedTbtc",msg:"Not enough wormhole tBTC in the gateway to bridge"},{code:6080,name:"ZeroAmount",msg:"Amount must not be 0"},{code:6112,name:"TransferAlreadyRedeemed",msg:"Token Bridge transfer already redeemed"},{code:6128,name:"InvalidEthereumTbtc",msg:"Token chain and address do not match Ethereum's tBTC"},{code:6144,name:"NoTbtcTransferred",msg:"No tBTC transferred"},{code:6160,name:"RecipientZeroAddress",msg:"0x0 receiver not allowed"},{code:6176,name:"MintedAmountUnderflow",msg:"Not enough minted by the gateway to satisfy sending tBTC"},{code:6178,name:"MintedAmountOverflow",msg:"Minted amount after deposit exceeds u64"}]};function G(i){return a.findProgramAddressSync([o.Buffer.from("redeemer")],new a(i))[0]}function Be(i,t){const e=o.Buffer.alloc(8);return e.writeBigUInt64LE(t),a.findProgramAddressSync([o.Buffer.from("msg"),e],new a(i))[0]}function Te(i,t){const e=o.Buffer.alloc(2);return e.writeUInt16LE(p(t)),a.findProgramAddressSync([o.Buffer.from("gateway-info"),e],new a(i))[0]}const B=new a("Gj93RRt6QB7FjmyokAD5rcMAku7pq3Fk2Aa8y6nNbwsV");function be(){return a.findProgramAddressSync([o.Buffer.from("config")],B)[0]}function le(i){return a.findProgramAddressSync([o.Buffer.from("minter-info"),i.toBuffer()],B)[0]}const T=new a("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");new a("TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb");const b=new a("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");new a("So11111111111111111111111111111111111111112");new a("9pan9bMn5HatX4EJdBwg9VgCa7Uz5HL8N1m5D3NdXejP");class Ae extends Error{constructor(t){super(t)}}class Ce extends Ae{constructor(){super(...arguments),this.name="TokenOwnerOffCurveError"}}const Ie=H([P("mintAuthorityOption"),v("mintAuthority"),j("supply"),Q("decimals"),X("isInitialized"),P("freezeAuthorityOption"),v("freezeAuthority")]);Ie.span;async function S(i,t,e=!1,n=T,r=b){if(!e&&!a.isOnCurve(t.toBuffer()))throw new Ce;const[s]=await a.findProgramAddress([t.toBuffer(),n.toBuffer(),i.toBuffer()],r);return s}function Pe(i,t,e,n,r=T,s=b){return ve(i,t,e,n,o.Buffer.alloc(0),r,s)}function ve(i,t,e,n,r,s=T,d=b){const c=[{pubkey:i,isSigner:!0,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:e,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:ue.programId,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!1}];return new he({keys:c,programId:d,data:r})}class l{constructor(t,e,n,r){if(m(this,"network"),m(this,"chain"),m(this,"connection"),m(this,"contracts"),m(this,"gateway"),m(this,"tokenBridgeId"),m(this,"coreBridgeId"),this.network=t,this.chain=e,this.connection=n,this.contracts=r,this.network!=="Mainnet")throw new Error("TBTC is only supported on Mainnet");if(!this.contracts.tbtc)throw new Error("TBTC contract address is required");if(!this.contracts.tokenBridge)throw new Error("TokenBridge contract address is required");if(!this.contracts.coreBridge)throw new Error("CoreBridge contract address is required");this.gateway=new J(Se,this.contracts.tbtc,{connection:n}),this.tokenBridgeId=new a(this.contracts.tokenBridge),this.coreBridgeId=new a(this.contracts.coreBridge)}static async fromRpc(t,e){const[n,r]=await _.chainFromRpc(t),s=e[r];if(s.network!==n)throw new Error(`Network mismatch: ${s.network} != ${n}`);return new l(n,r,t,s.contracts)}async*transfer(t,e,n){const r=new E(t).unwrap(),s=G(this.gateway.programId),{tbtcMint:d,wrappedTbtcToken:c,wrappedTbtcMint:h}=await this.gateway.account.custodian.fetch(s),g=L(this.tokenBridgeId,h),u=U(this.tokenBridgeId),y=pe(this.tokenBridgeId),w=Y(this.coreBridgeId),{sequence:f}=await ee(this.connection,this.tokenBridgeId,this.coreBridgeId),k=Be(this.gateway.programId,f),M=te(this.coreBridgeId),A=ie(this.tokenBridgeId),q=ne(A,this.coreBridgeId),D=Te(this.gateway.programId,e.chain),O=ye(this.gateway.programId),C={amount:new W.BN(n.toString()),recipientChain:p(e.chain),recipient:[...e.address.toUniversalAddress().toUint8Array()],nonce:0},$=await S(d,r),F=re.get(this.network,e.chain),I={custodian:s,wrappedTbtcToken:c,wrappedTbtcMint:h,tbtcMint:d,senderToken:$,sender:r,tokenBridgeConfig:u,tokenBridgeWrappedAsset:g,tokenBridgeTransferAuthority:y,coreBridgeData:M,coreMessage:k,tokenBridgeCoreEmitter:A,coreEmitterSequence:q,coreFeeCollector:w,clock:ae,rent:N,tokenBridgeProgram:this.tokenBridgeId,coreBridgeProgram:this.coreBridgeId},R=F?await this.gateway.methods.sendTbtcGateway({...C}).accounts({...I,gatewayInfo:D,tokenBridgeSender:O}).instruction():await this.gateway.methods.sendTbtcWrapped({...C,arbiterFee:new W.BN(0)}).accounts(I).instruction(),{blockhash:V}=await this.connection.getLatestBlockhash(),z=x.compile({instructions:[R],payerKey:r,recentBlockhash:V}),Z=new K(z);yield this.createUnsignedTransaction({transaction:Z},"TBTCBridge.Send")}async*redeem(t,e){if(e.payloadName!=="GatewayTransfer")throw new Error("Invalid VAA payload");yield*new se(this.network,this.chain,this.connection,this.contracts).postVaa(t,e);const n=[],r=new E(t).unwrap(),s=e.payload.payload.recipient.toNative(this.chain).unwrap(),d=G(this.gateway.programId),{tbtcMint:c,wrappedTbtcToken:h,wrappedTbtcMint:g}=await this.gateway.account.custodian.fetch(d),u=await S(c,s);await this.connection.getAccountInfo(u)||n.push(Pe(r,u,s,c));const y=L(this.tokenBridgeId,g),w=await S(g,s);n.push(await this.gateway.methods.receiveTbtc([...e.hash]).accounts({payer:r,custodian:d,postedVaa:oe(this.coreBridgeId,o.Buffer.from(e.hash)),tokenBridgeClaim:de(this.tokenBridgeId,e.emitterAddress.toUint8Array(),p(e.emitterChain),e.sequence),wrappedTbtcToken:h,wrappedTbtcMint:g,tbtcMint:c,recipientToken:u,recipient:s,recipientWrappedToken:w,tbtcConfig:be(),tbtcMinterInfo:le(d),tokenBridgeConfig:U(this.tokenBridgeId),tokenBridgeRegisteredEmitter:we(this.tokenBridgeId,p(e.emitterChain),e.emitterAddress.toUint8Array()),tokenBridgeWrappedAsset:y,tokenBridgeMintAuthority:fe(this.tokenBridgeId),rent:N,tbtcProgram:B,tokenBridgeProgram:this.tokenBridgeId,coreBridgeProgram:this.coreBridgeId}).instruction());const{blockhash:f}=await this.connection.getLatestBlockhash(),k=x.compile({instructions:n,payerKey:r,recentBlockhash:f}),M=new K(k);yield this.createUnsignedTransaction({transaction:M},"TBTCBridge.Send")}createUnsignedTransaction(t,e){return new ce(t,this.network,this.chain,e,!1)}}me(ge,"TBTCBridge",l);export{l as SolanaTBTCBridge};
