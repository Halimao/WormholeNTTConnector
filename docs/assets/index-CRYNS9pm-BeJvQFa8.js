import{c as l,X as p}from"./sui-B_AxArCa-Dtu7uBWp.js";import{dO as I,cQ as k,cO as _,cP as w,ab as S,cR as b,cN as y}from"./index-BGLdF6jF.js";import{h as C}from"./unsignedTransaction-BD81leu1-Cw-cn2l3.js";import"./blake2b-CAi92fbu-C8y-5OqJ.js";import"./index-wFZO7Yy8-CgrhUj91.js";var M=Object.defineProperty,j=(m,s,t)=>s in m?M(m,s,{enumerable:!0,configurable:!0,writable:!0,value:t}):m[s]=t,c=(m,s,t)=>j(m,typeof s!="symbol"?s+"":s,t);const E=[["Testnet",{tokenMessengerState:"0x5252abd1137094ed1db3e0d75bc36abcd287aee4bc310f8e047727ef5682e7c2",messageTransmitterState:"0x98234bd0fa9ac12cc0a20a144a22e36d6a32f7e0a97baaeaf9c76cdc6d122d2e",usdcTreasury:"0x7170137d4a6431bf83351ac025baf462909bffe2877d87716374fb42b9629ebe"}],["Mainnet",{tokenMessengerState:"0x45993eecc0382f37419864992c12faee2238f5cfe22b98ad3bf455baf65c8a2f",messageTransmitterState:"0xf68268c3d9b1df3215f2439400c1c4ea08ac4ef4bb7d6f3ca6a2a239e17510af",usdcTreasury:"0x57d6725e7a8b49a7b2a612f6bd66ab5f39fc95332ca48be421c3229d514a6de7"}]],$=I(E,[0,1]);class f{constructor(s,t,r,e){c(this,"network"),c(this,"chain"),c(this,"provider"),c(this,"contracts"),c(this,"usdcId"),c(this,"usdcTreasuryId"),c(this,"tokenMessengerId"),c(this,"tokenMessengerStateId"),c(this,"messageTransmitterId"),c(this,"messageTransmitterStateId");var a,n,o,i;if(this.network=s,this.chain=t,this.provider=r,this.contracts=e,s==="Devnet")throw new Error("CircleBridge not supported on Devnet");const d=k.get(this.network,this.chain);if(!d)throw new Error(`No USDC contract configured for network=${this.network} chain=${this.chain}`);const{tokenMessengerState:h,messageTransmitterState:g,usdcTreasury:u}=$(s);if(!((a=e.cctp)!=null&&a.tokenMessenger))throw new Error(`Circle Token Messenger contract for domain ${t} not found`);if(!((n=e.cctp)!=null&&n.messageTransmitter))throw new Error(`Circle Message Transmitter contract for domain ${t} not found`);this.usdcId=d,this.usdcTreasuryId=u,this.tokenMessengerId=(o=e.cctp)==null?void 0:o.tokenMessenger,this.messageTransmitterId=(i=e.cctp)==null?void 0:i.messageTransmitter,this.tokenMessengerStateId=h,this.messageTransmitterStateId=g}async*transfer(s,t,r){const e=new l,a=_.get(this.network,t.chain),[n,...o]=await p.getCoins(this.provider,s,this.usdcId);if(n===void 0)throw new Error("No USDC in wallet");const i=e.object(n.coinObjectId);o.length>0&&e.mergeCoins(i,o.map(h=>e.object(h.coinObjectId)));const[d]=e.splitCoins(i,[r]);e.moveCall({target:`${this.tokenMessengerId}::deposit_for_burn::deposit_for_burn`,arguments:[d,e.pure.u32(a),e.pure.address(t.address.toUniversalAddress().toString()),e.object(this.tokenMessengerStateId),e.object(this.messageTransmitterStateId),e.object("0x403"),e.object(this.usdcTreasuryId)],typeArguments:[this.usdcId]}),yield this.createUnsignedTx(e,"Sui.CircleBridge.Transfer")}async isTransferCompleted(s){const t=new l;t.moveCall({target:`${this.messageTransmitterId}::state::is_nonce_used`,arguments:[t.object(this.messageTransmitterStateId),t.pure.u32(s.sourceDomain),t.pure.u64(s.nonce)]});const r=await this.provider.devInspectTransactionBlock({sender:"0x0000000000000000000000000000000000000000000000000000000000000000",transactionBlock:t});try{return!!r.results[0].returnValues[0][0][0]}catch(e){return console.error(`Error reading if nonce was used: ${e}`),!1}}async*redeem(s,t,r){const e=new l,[a]=e.moveCall({target:`${this.messageTransmitterId}::receive_message::receive_message`,arguments:[e.pure.vector("u8",w.serialize(t)),e.pure.vector("u8",S.decode(r)),e.object(this.messageTransmitterStateId)]});if(!a)throw new Error("Failed to produce receipt");const[n]=e.moveCall({target:`${this.tokenMessengerId}::handle_receive_message::handle_receive_message`,arguments:[a,e.object(this.tokenMessengerStateId),e.object("0x403"),e.object(this.usdcTreasuryId)],typeArguments:[this.usdcId]});if(!n)throw new Error("Failed to produce stamp receipt ticket with burn message");const[o]=e.moveCall({target:`${this.tokenMessengerId}::handle_receive_message::deconstruct_stamp_receipt_ticket_with_burn_message`,arguments:[n]});if(!o)throw new Error("Failed to produce stamp receipt ticket");const[i]=e.moveCall({target:`${this.messageTransmitterId}::receive_message::stamp_receipt`,arguments:[o,e.object(this.messageTransmitterStateId)],typeArguments:[`${this.tokenMessengerId}::message_transmitter_authenticator::MessageTransmitterAuthenticator`]});if(!i)throw new Error("Failed to produce stamped receipt");e.moveCall({target:`${this.messageTransmitterId}::receive_message::complete_receive_message`,arguments:[i,e.object(this.messageTransmitterStateId)]}),yield this.createUnsignedTx(e,"Sui.CircleBridge.Redeem")}async parseTransactionDetails(s){var t;const r=await this.provider.waitForTransaction({digest:s,options:{showEvents:!0,showEffects:!0,showInput:!0}});if(!r)throw new Error("Transaction not found");if(!r.events)throw new Error("Transaction events not found");const e=(t=r.events)==null?void 0:t.find(T=>T.type.includes("send_message::MessageSent"));if(!e)throw new Error("No MessageSent event found");const a=new Uint8Array((e==null?void 0:e.parsedJson).message),[n,o]=w.deserialize(a),{payload:i}=n,d=i.messageSender,h=i.mintRecipient,g=b(this.network,n.sourceDomain),u=b(this.network,n.destinationDomain),v={chain:g,address:i.burnToken};return{from:{chain:g,address:d},to:{chain:u,address:h},token:v,amount:i.amount,message:n,id:{hash:o}}}static async fromRpc(s,t){const[r,e]=await p.chainFromRpc(s),a=t[e];if(a.network!==r)throw new Error(`Network mismatch: ${a.network} != ${r}`);return new f(r,e,s,a.contracts)}createUnsignedTx(s,t,r=!1){return new C(s,this.network,this.chain,t,r)}}y("Sui","CircleBridge",f);export{f as SuiCircleBridge,E as _suiCircleObjects,$ as suiCircleObjects};
