import{dI as m,dJ as B,dC as $,dK as g,cG as f,cY as b,cI as I,cZ as w,ab as o,bS as k,aa as c,a6 as h,dL as x,d1 as T,aC as S,b2 as U,a4 as _,cJ as u,dM as F,cN as C,dN as E}from"./index-BGLdF6jF.js";import{p as R}from"./aptos-DjCb_S8U-De6jfdQm.js";import{h as W}from"./unsignedTransaction-BDOQhqcZ-QEsV4D2I.js";import"./chunk-KJH4KKG6-CCerRpgp-CDfUDjNe.js";import"./index-wFZO7Yy8-CgrhUj91.js";import"./index-CuHybtft-BXlf5Z1L.js";var O=Object.defineProperty,Q=(a,e,t)=>e in a?O(a,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):a[e]=t,i=(a,e,t)=>Q(a,typeof e!="symbol"?e+"":e,t);const N=[{name:"tokenBridgeAddress",...m},{name:"chain",...B()},{name:"domainSeparator",binary:"bytes",custom:$.encode(g),omit:!0},{name:"tokenId",...m},{name:"domainSeparator",binary:"bytes",custom:new Uint8Array([255]),omit:!0}],j=a=>E(N,a);class d{constructor(e,t,s,n){i(this,"network"),i(this,"chain"),i(this,"connection"),i(this,"contracts"),i(this,"chainId"),i(this,"tokenBridgeAddress"),this.network=e,this.chain=t,this.connection=s,this.contracts=n,this.chainId=f(t);const r=n.tokenBridge;if(!r)throw new Error(`TokenBridge contract Address for chain ${t} not found`);this.tokenBridgeAddress=r}static async fromRpc(e,t){const[s,n]=await R.chainFromRpc(e),r=t[n];if(r.network!==s)throw new Error("Network mismatch "+r.network+" !== "+s);return new d(s,n,e,r.contracts)}async isWrappedAsset(e){try{return await this.getOriginalAsset(e),!0}catch{return!1}}async getOriginalAsset(e){const t=e.toString().split(g),s=await this.connection.getAccountResource({accountAddress:t[0],resourceType:`${this.tokenBridgeAddress}::state::OriginInfo`});if(!s)throw b(e.toString());const n=I(parseInt(s.token_chain.number)),r=new w(s.token_address.external_address);return{chain:n,address:r}}async getTokenUniversalAddress(e){return new w(o.encode(k(e.toString()),!0))}async getTokenNativeAddress(e,t){const s=e===this.chain?await this.getTypeFromExternalAddress(t.toString()):await this.getAssetFullyQualifiedType({chain:e,address:t});if(!s)throw new Error("Invalid asset address.");return new c(s)}async hasWrappedAsset(e){try{return await this.getWrappedAsset(e),!0}catch{}return!1}async getWrappedAsset(e){if(h(e.address))throw new Error("native asset cannot be a wrapped asset");const t=await this.getAssetFullyQualifiedType(e);if(!t)throw new Error("Invalid asset address.");return await this.connection.getAccountResource({accountAddress:x(t),resourceType:`${this.tokenBridgeAddress}::state::OriginInfo`}),T(this.chain,t)}async isTransferCompleted(e){const t=(await this.connection.getAccountResource({accountAddress:this.tokenBridgeAddress,resourceType:`${this.tokenBridgeAddress}::state::State`})).consumed_vaas.elems.handle;try{return await this.connection.getTableItem({handle:t,data:{key_type:"vector<u8>",value_type:"u8",key:`0x${S.Buffer.from(U(e.hash)).toString("hex")}`}}),!0}catch{return!1}}async getWrappedNative(){return T(this.chain,_)}async*createAttestation(e,t){const s={chain:this.chain,address:new c(e)},n=await this.getAssetFullyQualifiedType(s);if(!n)throw new Error("Invalid asset address.");yield this.createUnsignedTx({function:`${this.tokenBridgeAddress}::attest_token::attest_token_entry`,typeArguments:[n],functionArguments:[]},"Aptos.AttestToken")}async*submitAttestation(e,t){yield this.createUnsignedTx({function:`${this.tokenBridgeAddress}::wrapped::create_wrapped_coin_type`,typeArguments:[],functionArguments:[u(e)]},"Aptos.CreateWrappedCoinType");const s=await this.getAssetFullyQualifiedType(e.payload.token);if(!s)throw new Error("Invalid asset address.");yield this.createUnsignedTx({function:`${this.tokenBridgeAddress}::wrapped::create_wrapped_coin`,typeArguments:[s],functionArguments:[u(e)]},"Aptos.CreateWrappedCoin")}async*transfer(e,t,s,n,r){const v=0n,p=0n,y=h(s)?_:s.toString(),A=t.address.toUniversalAddress().toUint8Array(),l=f(t.chain);r?yield this.createUnsignedTx({function:`${this.tokenBridgeAddress}::transfer_tokens::transfer_tokens_with_payload_entry`,typeArguments:[y],functionArguments:[n,l,A,p,r]},"Aptos.TransferTokensWithPayload"):yield this.createUnsignedTx({function:`${this.tokenBridgeAddress}::transfer_tokens::transfer_tokens_entry`,typeArguments:[y],functionArguments:[n,l,A,v,p]},"Aptos.TransferTokens")}async*redeem(e,t,s=!0){const n=t.payload.token.chain===this.chain?await this.getTypeFromExternalAddress(t.payload.token.address.toString()):await this.getAssetFullyQualifiedType(t.payload.token);if(!n)throw new Error("Invalid asset address.");yield this.createUnsignedTx({function:`${this.tokenBridgeAddress}::complete_transfer::submit_vaa_and_register_entry`,typeArguments:[n],functionArguments:[u(t)]},"Aptos.CompleteTransfer")}async getAssetFullyQualifiedType(e){return e.chain===this.chain?F(e.address.toString())?e.address.toString():null:`${d.getForeignAssetAddress(this.chain,this.tokenBridgeAddress,e)}::coin::T`}async getTypeFromExternalAddress(e){try{const t=await this.connection.getAccountResource({accountAddress:this.tokenBridgeAddress,resourceType:`${this.tokenBridgeAddress}::state::State`}),{handle:s}=t.native_infos,n=await this.connection.getTableItem({handle:s,data:{key_type:`${this.tokenBridgeAddress}::token_hash::TokenHash`,value_type:"0x1::type_info::TypeInfo",key:{hash:e}}});return n?[n.account_address,String.fromCharCode(...o.decode(n.module_name)),String.fromCharCode(...o.decode(n.struct_name))].join(g):null}catch{return null}}static getForeignAssetAddress(e,t,s){if(h(s.address))throw new Error("Invalid token address");const n=j({chain:s.chain,tokenBridgeAddress:new c(t).toUniversalAddress(),tokenId:s.address.toUniversalAddress()});return o.encode(k(n),!0)}createUnsignedTx(e,t,s=!1){return new W(e,this.network,this.chain,t,s)}}C("Aptos","TokenBridge",d);export{d as AptosTokenBridge};
