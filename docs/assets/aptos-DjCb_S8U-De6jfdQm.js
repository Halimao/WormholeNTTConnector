const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/index-Naa9NLXw-CAMAmYRr.js","assets/index-BGLdF6jF.js","assets/index-CUtl-BF5.css","assets/chunk-KJH4KKG6-CCerRpgp-CDfUDjNe.js","assets/index-wFZO7Yy8-CgrhUj91.js","assets/index-CuHybtft-BXlf5Z1L.js","assets/index-XkPtmd0r-ReRHfHGL.js","assets/unsignedTransaction-BDOQhqcZ-QEsV4D2I.js","assets/index-D1vSocUD-DPY62rdv.js"])))=>i.map(i=>d[i]);
import{a0 as b,a1 as y,a2 as v,a3 as S,a4 as u,a5 as T,a6 as p,a7 as I,a8 as E,a9 as g,aa as A,_ as l,L as C,ab as k}from"./index-BGLdF6jF.js";import{h as _,w as N,m as P,l as B,q as F}from"./chunk-KJH4KKG6-CCerRpgp-CDfUDjNe.js";var L=Object.defineProperty,O=(n,t,a)=>t in n?L(n,t,{enumerable:!0,configurable:!0,writable:!0,value:a}):n[t]=a,j=(n,t,a)=>O(n,t+"",a);class f extends b{}const w=class c extends y{constructor(t,a){super(t,a??v(t,c._platform))}getRpc(t){if(t in this.config){const a=this.network==="Mainnet"?_.MAINNET:_.TESTNET,e=new N({fullnode:this.config[t].rpc,network:a});return new P(e)}throw new Error("No configuration available for chain: "+t)}getChain(t,a){if(t in this.config)return new f(t,this);throw new Error("No configuration available for chain: "+t)}static nativeTokenId(t,a){if(!this.isSupportedChain(a))throw new Error(`invalid chain: ${a}`);return S.tokenId(a,u)}static isNativeTokenId(t,a,e){return!this.isSupportedChain(a)||e.chain!==a?!1:this.nativeTokenId(t,a)==e}static isSupportedChain(t){return T(t)===c._platform}static async getDecimals(t,a,e){if(p(e)||e===u)return I(c._platform);const s=e.toString();return(await a.getFungibleAssetMetadataByAssetType({assetType:s})).decimals}static async getBalance(t,a,e,s){var i;const o=p(s)?u:s.toString();try{return((i=(await a.getCurrentFungibleAssetBalances({options:{where:{owner_address:{_eq:e},asset_type:{_eq:o}}}}))[0])==null?void 0:i.amount)??null}catch(r){if(r.status===404)return null;throw r}}static async getBalances(t,a,e,s){try{const i=await a.getCurrentFungibleAssetBalances({options:{where:{owner_address:{_eq:e}}}});let o={};for(const r of i)if(r.asset_type){let m=r.asset_type==="0x1::aptos_coin::AptosCoin"?"native":r.asset_type;o[m]=r.amount}return o}catch(i){if(i.status===404)return{};throw i}}static async sendWait(t,a,e){const s=[];for(const i of e){const o=await a.transaction.submit.simple(i.transaction),r=await a.waitForTransaction({transactionHash:o.hash});s.push(r.hash)}return s}static async getLatestBlock(t){const a=await t.getLedgerInfo();return Number(a.block_height)}static async getLatestFinalizedBlock(t){const a=await t.getLedgerInfo();return Number(a.block_height)}static chainFromChainId(t){const a=E(c._platform,BigInt(t));if(!a)throw new Error(`No matching chainId to determine network and chain: ${t}`);const[e,s]=a;return[e,s]}static async chainFromRpc(t){const a=await t.getLedgerInfo();return this.chainFromChainId(a.chain_id.toString())}};j(w,"_platform",g);let d=w;var $=Object.defineProperty,q=(n,t,a)=>t in n?$(n,t,{enumerable:!0,configurable:!0,writable:!0,value:a}):n[t]=a,h=(n,t,a)=>q(n,typeof t!="symbol"?t+"":t,a);async function R(n,t){const[a,e]=await d.chainFromRpc(n),s=B.fromPrivateKey({privateKey:new F(k.decode(t))});return new x(e,s,n)}class x{constructor(t,a,e,s){h(this,"_chain"),h(this,"_account"),h(this,"_rpc"),h(this,"_debug"),this._chain=t,this._account=a,this._rpc=e,this._debug=s}chain(){return this._chain}address(){return this._account.accountAddress.toString()}async signAndSend(t){const a=[];for(const e of t){const{description:s,transaction:i}=e;this._debug&&console.log(`Signing: ${s} for ${this.address()}`);const o=await this._rpc.transaction.build.simple({sender:this._account.accountAddress,data:i}),{hash:r}=await this._simSignSend(o);a.push(r)}return a}async _simSignSend(t){return await this._rpc.transaction.simulate.simple({signerPublicKey:this._account.publicKey,transaction:t}).then(a=>a.forEach(e=>{if(!e.success)throw new Error(`Transaction failed: ${e.vm_status}
${JSON.stringify(e,null,2)}`)})),this._rpc.signAndSubmitTransaction({signer:this._account,transaction:t}).then(a=>this._rpc.waitForTransaction({transactionHash:a.hash}))}}const D={Address:A,Platform:d,getSigner:R,protocols:{WormholeCore:()=>l(()=>import("./index-Naa9NLXw-CAMAmYRr.js"),__vite__mapDeps([0,1,2,3,4,5])),TokenBridge:()=>l(()=>import("./index-XkPtmd0r-ReRHfHGL.js"),__vite__mapDeps([6,1,2,7,3,4,5])),CircleBridge:()=>l(()=>import("./index-D1vSocUD-DPY62rdv.js"),__vite__mapDeps([8,3,1,2,4,5,7]))},getChain:(n,t,a)=>new f(t,new d(n,C(n,g,{[t]:a})))},V=Object.freeze(Object.defineProperty({__proto__:null,default:D},Symbol.toStringTag,{value:"Module"}));export{V as a,d as p};
