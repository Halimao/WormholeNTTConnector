import{a4 as le,a3 as de,$ as ge,V as Jt,a1 as we,Z as Qt,Y as vt,a2 as pe,X as It,_ as ye,a0 as Y}from"./solana-CIjJKPC4-DDalIXxg.js";import"./index-BGLdF6jF.js";import"./util--bw7gFPs-CFDtl-lf.js";import"./wallets-B2tqS5lZ-CMHWyddi.js";import"./signer-CinqaaXD-CK79ZFw-.js";import"./index-CNWcuxPc-C5KIuBWR.js";import"./index.es-CEy-pF4C-DURb_lgF.js";function me(r,e,t,n){if(typeof r.setBigUint64=="function")return r.setBigUint64(e,t,n);const o=BigInt(32),f=BigInt(4294967295),i=Number(t>>o&f),c=Number(t&f),s=n?4:0,u=n?0:4;r.setUint32(e+s,i,n),r.setUint32(e+u,c,n)}function Ee(r,e,t){return r&e^~r&t}function be(r,e,t){return r&e^r&t^e&t}class Be extends Jt{constructor(e,t,n,o){super(),this.blockLen=e,this.outputLen=t,this.padOffset=n,this.isLE=o,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=It(this.buffer)}update(e){vt(this);const{view:t,buffer:n,blockLen:o}=this;e=Qt(e);const f=e.length;for(let i=0;i<f;){const c=Math.min(o-this.pos,f-i);if(c===o){const s=It(e);for(;o<=f-i;i+=o)this.process(s,i);continue}n.set(e.subarray(i,i+c),this.pos),this.pos+=c,i+=c,this.pos===o&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){vt(this),ye(e,this),this.finished=!0;const{buffer:t,view:n,blockLen:o,isLE:f}=this;let{pos:i}=this;t[i++]=128,this.buffer.subarray(i).fill(0),this.padOffset>o-i&&(this.process(n,0),i=0);for(let w=i;w<o;w++)t[w]=0;me(n,o-8,BigInt(this.length*8),f),this.process(n,0);const c=It(e),s=this.outputLen;if(s%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const u=s/4,g=this.get();if(u>g.length)throw new Error("_sha2: outputLen bigger than state");for(let w=0;w<u;w++)c.setUint32(4*w,g[w],f)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const n=e.slice(0,t);return this.destroy(),n}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:t,buffer:n,length:o,finished:f,destroyed:i,pos:c}=this;return e.length=o,e.pos=c,e.finished=f,e.destroyed=i,o%t&&e.buffer.set(n),e}}const ve=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),J=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),Q=new Uint32Array(64);class xe extends Be{constructor(){super(64,32,8,!1),this.A=J[0]|0,this.B=J[1]|0,this.C=J[2]|0,this.D=J[3]|0,this.E=J[4]|0,this.F=J[5]|0,this.G=J[6]|0,this.H=J[7]|0}get(){const{A:e,B:t,C:n,D:o,E:f,F:i,G:c,H:s}=this;return[e,t,n,o,f,i,c,s]}set(e,t,n,o,f,i,c,s){this.A=e|0,this.B=t|0,this.C=n|0,this.D=o|0,this.E=f|0,this.F=i|0,this.G=c|0,this.H=s|0}process(e,t){for(let w=0;w<16;w++,t+=4)Q[w]=e.getUint32(t,!1);for(let w=16;w<64;w++){const h=Q[w-15],x=Q[w-2],S=Y(h,7)^Y(h,18)^h>>>3,E=Y(x,17)^Y(x,19)^x>>>10;Q[w]=E+Q[w-7]+S+Q[w-16]|0}let{A:n,B:o,C:f,D:i,E:c,F:s,G:u,H:g}=this;for(let w=0;w<64;w++){const h=Y(c,6)^Y(c,11)^Y(c,25),x=g+h+Ee(c,s,u)+ve[w]+Q[w]|0,S=(Y(n,2)^Y(n,13)^Y(n,22))+be(n,o,f)|0;g=u,u=s,s=c,c=i+x|0,i=f,f=o,o=n,n=x+S|0}n=n+this.A|0,o=o+this.B|0,f=f+this.C|0,i=i+this.D|0,c=c+this.E|0,s=s+this.F|0,u=u+this.G|0,g=g+this.H|0,this.set(n,o,f,i,c,s,u,g)}roundClean(){Q.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const Se=ge(()=>new xe);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const xt=BigInt(0),St=BigInt(1),Ae=BigInt(2);function st(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&r.constructor.name==="Uint8Array"}function yt(r){if(!st(r))throw new Error("Uint8Array expected")}function at(r,e){if(typeof e!="boolean")throw new Error(r+" boolean expected, got "+e)}const Ie=Array.from({length:256},(r,e)=>e.toString(16).padStart(2,"0"));function ut(r){yt(r);let e="";for(let t=0;t<r.length;t++)e+=Ie[r[t]];return e}function ct(r){const e=r.toString(16);return e.length&1?"0"+e:e}function Ct(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);return r===""?xt:BigInt("0x"+r)}const W={_0:48,_9:57,A:65,F:70,a:97,f:102};function Dt(r){if(r>=W._0&&r<=W._9)return r-W._0;if(r>=W.A&&r<=W.F)return r-(W.A-10);if(r>=W.a&&r<=W.f)return r-(W.a-10)}function ht(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);const e=r.length,t=e/2;if(e%2)throw new Error("hex string expected, got unpadded hex of length "+e);const n=new Uint8Array(t);for(let o=0,f=0;o<t;o++,f+=2){const i=Dt(r.charCodeAt(f)),c=Dt(r.charCodeAt(f+1));if(i===void 0||c===void 0){const s=r[f]+r[f+1];throw new Error('hex string expected, got non-hex character "'+s+'" at index '+f)}n[o]=i*16+c}return n}function ot(r){return Ct(ut(r))}function Pt(r){return yt(r),Ct(ut(Uint8Array.from(r).reverse()))}function lt(r,e){return ht(r.toString(16).padStart(e*2,"0"))}function Zt(r,e){return lt(r,e).reverse()}function Oe(r){return ht(ct(r))}function G(r,e,t){let n;if(typeof e=="string")try{n=ht(e)}catch(f){throw new Error(r+" must be hex string or Uint8Array, cause: "+f)}else if(st(e))n=Uint8Array.from(e);else throw new Error(r+" must be hex string or Uint8Array");const o=n.length;if(typeof t=="number"&&o!==t)throw new Error(r+" of length "+t+" expected, got "+o);return n}function pt(...r){let e=0;for(let n=0;n<r.length;n++){const o=r[n];yt(o),e+=o.length}const t=new Uint8Array(e);for(let n=0,o=0;n<r.length;n++){const f=r[n];t.set(f,o),o+=f.length}return t}function qe(r,e){if(r.length!==e.length)return!1;let t=0;for(let n=0;n<r.length;n++)t|=r[n]^e[n];return t===0}function Ne(r){if(typeof r!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(r))}const Ot=r=>typeof r=="bigint"&&xt<=r;function At(r,e,t){return Ot(r)&&Ot(e)&&Ot(t)&&e<=r&&r<t}function it(r,e,t,n){if(!At(e,t,n))throw new Error("expected valid "+r+": "+t+" <= n < "+n+", got "+e)}function te(r){let e;for(e=0;r>xt;r>>=St,e+=1);return e}function Le(r,e){return r>>BigInt(e)&St}function Re(r,e,t){return r|(t?St:xt)<<BigInt(e)}const Vt=r=>(Ae<<BigInt(r-1))-St,qt=r=>new Uint8Array(r),Kt=r=>Uint8Array.from(r);function ee(r,e,t){if(typeof r!="number"||r<2)throw new Error("hashLen must be a number");if(typeof e!="number"||e<2)throw new Error("qByteLen must be a number");if(typeof t!="function")throw new Error("hmacFn must be a function");let n=qt(r),o=qt(r),f=0;const i=()=>{n.fill(1),o.fill(0),f=0},c=(...g)=>t(o,n,...g),s=(g=qt())=>{o=c(Kt([0]),g),n=c(),g.length!==0&&(o=c(Kt([1]),g),n=c())},u=()=>{if(f++>=1e3)throw new Error("drbg: tried 1000 values");let g=0;const w=[];for(;g<e;){n=c();const h=n.slice();w.push(h),g+=n.length}return pt(...w)};return(g,w)=>{i(),s(g);let h;for(;!(h=w(u()));)s();return i(),h}}const He={bigint:r=>typeof r=="bigint",function:r=>typeof r=="function",boolean:r=>typeof r=="boolean",string:r=>typeof r=="string",stringOrUint8Array:r=>typeof r=="string"||st(r),isSafeInteger:r=>Number.isSafeInteger(r),array:r=>Array.isArray(r),field:(r,e)=>e.Fp.isValid(r),hash:r=>typeof r=="function"&&Number.isSafeInteger(r.outputLen)};function mt(r,e,t={}){const n=(o,f,i)=>{const c=He[f];if(typeof c!="function")throw new Error("invalid validator function");const s=r[o];if(!(i&&s===void 0)&&!c(s,r))throw new Error("param "+String(o)+" is invalid. Expected "+f+", got "+s)};for(const[o,f]of Object.entries(e))n(o,f,!1);for(const[o,f]of Object.entries(t))n(o,f,!0);return r}const Ue=()=>{throw new Error("not implemented")};function Ut(r){const e=new WeakMap;return(t,...n)=>{const o=e.get(t);if(o!==void 0)return o;const f=r(t,...n);return e.set(t,f),f}}const ke=Object.freeze(Object.defineProperty({__proto__:null,aInRange:it,abool:at,abytes:yt,bitGet:Le,bitLen:te,bitMask:Vt,bitSet:Re,bytesToHex:ut,bytesToNumberBE:ot,bytesToNumberLE:Pt,concatBytes:pt,createHmacDrbg:ee,ensureBytes:G,equalBytes:qe,hexToBytes:ht,hexToNumber:Ct,inRange:At,isBytes:st,memoized:Ut,notImplemented:Ue,numberToBytesBE:lt,numberToBytesLE:Zt,numberToHexUnpadded:ct,numberToVarBytesBE:Oe,utf8ToBytes:Ne,validateObject:mt},Symbol.toStringTag,{value:"Module"}));class re extends Jt{constructor(e,t){super(),this.finished=!1,this.destroyed=!1,we(e);const n=Qt(t);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const o=this.blockLen,f=new Uint8Array(o);f.set(n.length>o?e.create().update(n).digest():n);for(let i=0;i<f.length;i++)f[i]^=54;this.iHash.update(f),this.oHash=e.create();for(let i=0;i<f.length;i++)f[i]^=106;this.oHash.update(f),f.fill(0)}update(e){return vt(this),this.iHash.update(e),this}digestInto(e){vt(this),pe(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:t,iHash:n,finished:o,destroyed:f,blockLen:i,outputLen:c}=this;return e=e,e.finished=o,e.destroyed=f,e.blockLen=i,e.outputLen=c,e.oHash=t._cloneInto(e.oHash),e.iHash=n._cloneInto(e.iHash),e}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const ne=(r,e,t)=>new re(r,e).update(t).digest();ne.create=(r,e)=>new re(r,e);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const z=BigInt(0),k=BigInt(1),nt=BigInt(2),Fe=BigInt(3),kt=BigInt(4),Gt=BigInt(5),Mt=BigInt(8);function P(r,e){const t=r%e;return t>=z?t:e+t}function ze(r,e,t){if(e<z)throw new Error("invalid exponent, negatives unsupported");if(t<=z)throw new Error("invalid modulus");if(t===k)return z;let n=k;for(;e>z;)e&k&&(n=n*r%t),r=r*r%t,e>>=k;return n}function j(r,e,t){let n=r;for(;e-- >z;)n*=n,n%=t;return n}function Ft(r,e){if(r===z)throw new Error("invert: expected non-zero number");if(e<=z)throw new Error("invert: expected positive modulus, got "+e);let t=P(r,e),n=e,o=z,f=k;for(;t!==z;){const i=n/t,c=n%t,s=o-f*i;n=t,t=c,o=f,f=s}if(n!==k)throw new Error("invert: does not exist");return P(o,e)}function Te(r){const e=(r-k)/nt;let t,n,o;for(t=r-k,n=0;t%nt===z;t/=nt,n++);for(o=nt;o<r&&ze(o,e,r)!==r-k;o++)if(o>1e3)throw new Error("Cannot find square root: likely non-prime P");if(n===1){const i=(r+k)/kt;return function(c,s){const u=c.pow(s,i);if(!c.eql(c.sqr(u),s))throw new Error("Cannot find square root");return u}}const f=(t+k)/nt;return function(i,c){if(i.pow(c,e)===i.neg(i.ONE))throw new Error("Cannot find square root");let s=n,u=i.pow(i.mul(i.ONE,o),t),g=i.pow(c,f),w=i.pow(c,t);for(;!i.eql(w,i.ONE);){if(i.eql(w,i.ZERO))return i.ZERO;let h=1;for(let S=i.sqr(w);h<s&&!i.eql(S,i.ONE);h++)S=i.sqr(S);const x=i.pow(u,k<<BigInt(s-h-1));u=i.sqr(x),g=i.mul(g,x),w=i.mul(w,u),s=h}return g}}function Ce(r){if(r%kt===Fe){const e=(r+k)/kt;return function(t,n){const o=t.pow(n,e);if(!t.eql(t.sqr(o),n))throw new Error("Cannot find square root");return o}}if(r%Mt===Gt){const e=(r-Gt)/Mt;return function(t,n){const o=t.mul(n,nt),f=t.pow(o,e),i=t.mul(n,f),c=t.mul(t.mul(i,nt),f),s=t.mul(i,t.sub(c,t.ONE));if(!t.eql(t.sqr(s),n))throw new Error("Cannot find square root");return s}}return Te(r)}const Pe=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Ze(r){const e={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},t=Pe.reduce((n,o)=>(n[o]="function",n),e);return mt(r,t)}function Ve(r,e,t){if(t<z)throw new Error("invalid exponent, negatives unsupported");if(t===z)return r.ONE;if(t===k)return e;let n=r.ONE,o=e;for(;t>z;)t&k&&(n=r.mul(n,o)),o=r.sqr(o),t>>=k;return n}function je(r,e){const t=new Array(e.length),n=e.reduce((f,i,c)=>r.is0(i)?f:(t[c]=f,r.mul(f,i)),r.ONE),o=r.inv(n);return e.reduceRight((f,i,c)=>r.is0(i)?f:(t[c]=r.mul(f,t[c]),r.mul(f,i)),o),t}function oe(r,e){const t=e!==void 0?e:r.toString(2).length,n=Math.ceil(t/8);return{nBitLength:t,nByteLength:n}}function ie(r,e,t=!1,n={}){if(r<=z)throw new Error("invalid field: expected ORDER > 0, got "+r);const{nBitLength:o,nByteLength:f}=oe(r,e);if(f>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let i;const c=Object.freeze({ORDER:r,isLE:t,BITS:o,BYTES:f,MASK:Vt(o),ZERO:z,ONE:k,create:s=>P(s,r),isValid:s=>{if(typeof s!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof s);return z<=s&&s<r},is0:s=>s===z,isOdd:s=>(s&k)===k,neg:s=>P(-s,r),eql:(s,u)=>s===u,sqr:s=>P(s*s,r),add:(s,u)=>P(s+u,r),sub:(s,u)=>P(s-u,r),mul:(s,u)=>P(s*u,r),pow:(s,u)=>Ve(c,s,u),div:(s,u)=>P(s*Ft(u,r),r),sqrN:s=>s*s,addN:(s,u)=>s+u,subN:(s,u)=>s-u,mulN:(s,u)=>s*u,inv:s=>Ft(s,r),sqrt:n.sqrt||(s=>(i||(i=Ce(r)),i(c,s))),invertBatch:s=>je(c,s),cmov:(s,u,g)=>g?u:s,toBytes:s=>t?Zt(s,f):lt(s,f),fromBytes:s=>{if(s.length!==f)throw new Error("Field.fromBytes: expected "+f+" bytes, got "+s.length);return t?Pt(s):ot(s)}});return Object.freeze(c)}function se(r){if(typeof r!="bigint")throw new Error("field order must be bigint");const e=r.toString(2).length;return Math.ceil(e/8)}function fe(r){const e=se(r);return e+Math.ceil(e/2)}function De(r,e,t=!1){const n=r.length,o=se(e),f=fe(e);if(n<16||n<f||n>1024)throw new Error("expected "+f+"-1024 bytes of input, got "+n);const i=t?Pt(r):ot(r),c=P(i,e-k)+k;return t?Zt(c,o):lt(c,o)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Yt=BigInt(0),Bt=BigInt(1);function Nt(r,e){const t=e.negate();return r?t:e}function ce(r,e){if(!Number.isSafeInteger(r)||r<=0||r>e)throw new Error("invalid window size, expected [1.."+e+"], got W="+r)}function Lt(r,e){ce(r,e);const t=Math.ceil(e/r)+1,n=2**(r-1);return{windows:t,windowSize:n}}function Ke(r,e){if(!Array.isArray(r))throw new Error("array expected");r.forEach((t,n)=>{if(!(t instanceof e))throw new Error("invalid point at index "+n)})}function Ge(r,e){if(!Array.isArray(r))throw new Error("array of scalars expected");r.forEach((t,n)=>{if(!e.isValid(t))throw new Error("invalid scalar at index "+n)})}const Rt=new WeakMap,ae=new WeakMap;function Ht(r){return ae.get(r)||1}function Me(r,e){return{constTimeNegate:Nt,hasPrecomputes(t){return Ht(t)!==1},unsafeLadder(t,n,o=r.ZERO){let f=t;for(;n>Yt;)n&Bt&&(o=o.add(f)),f=f.double(),n>>=Bt;return o},precomputeWindow(t,n){const{windows:o,windowSize:f}=Lt(n,e),i=[];let c=t,s=c;for(let u=0;u<o;u++){s=c,i.push(s);for(let g=1;g<f;g++)s=s.add(c),i.push(s);c=s.double()}return i},wNAF(t,n,o){const{windows:f,windowSize:i}=Lt(t,e);let c=r.ZERO,s=r.BASE;const u=BigInt(2**t-1),g=2**t,w=BigInt(t);for(let h=0;h<f;h++){const x=h*i;let S=Number(o&u);o>>=w,S>i&&(S-=g,o+=Bt);const E=x,a=x+Math.abs(S)-1,d=h%2!==0,m=S<0;S===0?s=s.add(Nt(d,n[E])):c=c.add(Nt(m,n[a]))}return{p:c,f:s}},wNAFUnsafe(t,n,o,f=r.ZERO){const{windows:i,windowSize:c}=Lt(t,e),s=BigInt(2**t-1),u=2**t,g=BigInt(t);for(let w=0;w<i;w++){const h=w*c;if(o===Yt)break;let x=Number(o&s);if(o>>=g,x>c&&(x-=u,o+=Bt),x===0)continue;let S=n[h+Math.abs(x)-1];x<0&&(S=S.negate()),f=f.add(S)}return f},getPrecomputes(t,n,o){let f=Rt.get(n);return f||(f=this.precomputeWindow(n,t),t!==1&&Rt.set(n,o(f))),f},wNAFCached(t,n,o){const f=Ht(t);return this.wNAF(f,this.getPrecomputes(f,t,o),n)},wNAFCachedUnsafe(t,n,o,f){const i=Ht(t);return i===1?this.unsafeLadder(t,n,f):this.wNAFUnsafe(i,this.getPrecomputes(i,t,o),n,f)},setWindowSize(t,n){ce(n,e),ae.set(t,n),Rt.delete(t)}}}function Ye(r,e,t,n){if(Ke(t,r),Ge(n,e),t.length!==n.length)throw new Error("arrays of points and scalars must have equal length");const o=r.ZERO,f=te(BigInt(t.length)),i=f>12?f-3:f>4?f-2:f?2:1,c=(1<<i)-1,s=new Array(c+1).fill(o),u=Math.floor((e.BITS-1)/i)*i;let g=o;for(let w=u;w>=0;w-=i){s.fill(o);for(let x=0;x<n.length;x++){const S=n[x],E=Number(S>>BigInt(w)&BigInt(c));s[E]=s[E].add(t[x])}let h=o;for(let x=s.length-1,S=o;x>0;x--)S=S.add(s[x]),h=h.add(S);if(g=g.add(h),w!==0)for(let x=0;x<i;x++)g=g.double()}return g}function ue(r){return Ze(r.Fp),mt(r,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...oe(r.n,r.nBitLength),...r,p:r.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Wt(r){r.lowS!==void 0&&at("lowS",r.lowS),r.prehash!==void 0&&at("prehash",r.prehash)}function We(r){const e=ue(r);mt(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:t,Fp:n,a:o}=e;if(t){if(!n.eql(o,n.ZERO))throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");if(typeof t!="object"||typeof t.beta!="bigint"||typeof t.splitScalar!="function")throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function")}return Object.freeze({...e})}const{bytesToNumberBE:_e,hexToBytes:Xe}=ke;class $e extends Error{constructor(e=""){super(e)}}const _={Err:$e,_tlv:{encode:(r,e)=>{const{Err:t}=_;if(r<0||r>256)throw new t("tlv.encode: wrong tag");if(e.length&1)throw new t("tlv.encode: unpadded data");const n=e.length/2,o=ct(n);if(o.length/2&128)throw new t("tlv.encode: long form length too big");const f=n>127?ct(o.length/2|128):"";return ct(r)+f+o+e},decode(r,e){const{Err:t}=_;let n=0;if(r<0||r>256)throw new t("tlv.encode: wrong tag");if(e.length<2||e[n++]!==r)throw new t("tlv.decode: wrong tlv");const o=e[n++],f=!!(o&128);let i=0;if(!f)i=o;else{const s=o&127;if(!s)throw new t("tlv.decode(long): indefinite length not supported");if(s>4)throw new t("tlv.decode(long): byte length is too big");const u=e.subarray(n,n+s);if(u.length!==s)throw new t("tlv.decode: length bytes not complete");if(u[0]===0)throw new t("tlv.decode(long): zero leftmost byte");for(const g of u)i=i<<8|g;if(n+=s,i<128)throw new t("tlv.decode(long): not minimal encoding")}const c=e.subarray(n,n+i);if(c.length!==i)throw new t("tlv.decode: wrong value length");return{v:c,l:e.subarray(n+i)}}},_int:{encode(r){const{Err:e}=_;if(r<X)throw new e("integer: negative integers are not allowed");let t=ct(r);if(Number.parseInt(t[0],16)&8&&(t="00"+t),t.length&1)throw new e("unexpected DER parsing assertion: unpadded hex");return t},decode(r){const{Err:e}=_;if(r[0]&128)throw new e("invalid signature integer: negative");if(r[0]===0&&!(r[1]&128))throw new e("invalid signature integer: unnecessary leading zero");return _e(r)}},toSig(r){const{Err:e,_int:t,_tlv:n}=_,o=typeof r=="string"?Xe(r):r;yt(o);const{v:f,l:i}=n.decode(48,o);if(i.length)throw new e("invalid signature: left bytes after parsing");const{v:c,l:s}=n.decode(2,f),{v:u,l:g}=n.decode(2,s);if(g.length)throw new e("invalid signature: left bytes after parsing");return{r:t.decode(c),s:t.decode(u)}},hexFromSig(r){const{_tlv:e,_int:t}=_,n=e.encode(2,t.encode(r.r)),o=e.encode(2,t.encode(r.s)),f=n+o;return e.encode(48,f)}},X=BigInt(0),F=BigInt(1);BigInt(2);const _t=BigInt(3);BigInt(4);function Je(r){const e=We(r),{Fp:t}=e,n=ie(e.n,e.nBitLength),o=e.toBytes||((E,a,d)=>{const m=a.toAffine();return pt(Uint8Array.from([4]),t.toBytes(m.x),t.toBytes(m.y))}),f=e.fromBytes||(E=>{const a=E.subarray(1),d=t.fromBytes(a.subarray(0,t.BYTES)),m=t.fromBytes(a.subarray(t.BYTES,2*t.BYTES));return{x:d,y:m}});function i(E){const{a,b:d}=e,m=t.sqr(E),b=t.mul(m,E);return t.add(t.add(b,t.mul(E,a)),d)}if(!t.eql(t.sqr(e.Gy),i(e.Gx)))throw new Error("bad generator point: equation left != right");function c(E){return At(E,F,e.n)}function s(E){const{allowedPrivateKeyLengths:a,nByteLength:d,wrapPrivateKey:m,n:b}=e;if(a&&typeof E!="bigint"){if(st(E)&&(E=ut(E)),typeof E!="string"||!a.includes(E.length))throw new Error("invalid private key");E=E.padStart(d*2,"0")}let q;try{q=typeof E=="bigint"?E:ot(G("private key",E,d))}catch{throw new Error("invalid private key, expected hex or "+d+" bytes, got "+typeof E)}return m&&(q=P(q,b)),it("private key",q,F,b),q}function u(E){if(!(E instanceof h))throw new Error("ProjectivePoint expected")}const g=Ut((E,a)=>{const{px:d,py:m,pz:b}=E;if(t.eql(b,t.ONE))return{x:d,y:m};const q=E.is0();a==null&&(a=q?t.ONE:t.inv(b));const L=t.mul(d,a),O=t.mul(m,a),B=t.mul(b,a);if(q)return{x:t.ZERO,y:t.ZERO};if(!t.eql(B,t.ONE))throw new Error("invZ was invalid");return{x:L,y:O}}),w=Ut(E=>{if(E.is0()){if(e.allowInfinityPoint&&!t.is0(E.py))return;throw new Error("bad point: ZERO")}const{x:a,y:d}=E.toAffine();if(!t.isValid(a)||!t.isValid(d))throw new Error("bad point: x or y not FE");const m=t.sqr(d),b=i(a);if(!t.eql(m,b))throw new Error("bad point: equation left != right");if(!E.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class h{constructor(a,d,m){if(this.px=a,this.py=d,this.pz=m,a==null||!t.isValid(a))throw new Error("x required");if(d==null||!t.isValid(d))throw new Error("y required");if(m==null||!t.isValid(m))throw new Error("z required");Object.freeze(this)}static fromAffine(a){const{x:d,y:m}=a||{};if(!a||!t.isValid(d)||!t.isValid(m))throw new Error("invalid affine point");if(a instanceof h)throw new Error("projective point not allowed");const b=q=>t.eql(q,t.ZERO);return b(d)&&b(m)?h.ZERO:new h(d,m,t.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(a){const d=t.invertBatch(a.map(m=>m.pz));return a.map((m,b)=>m.toAffine(d[b])).map(h.fromAffine)}static fromHex(a){const d=h.fromAffine(f(G("pointHex",a)));return d.assertValidity(),d}static fromPrivateKey(a){return h.BASE.multiply(s(a))}static msm(a,d){return Ye(h,n,a,d)}_setWindowSize(a){S.setWindowSize(this,a)}assertValidity(){w(this)}hasEvenY(){const{y:a}=this.toAffine();if(t.isOdd)return!t.isOdd(a);throw new Error("Field doesn't support isOdd")}equals(a){u(a);const{px:d,py:m,pz:b}=this,{px:q,py:L,pz:O}=a,B=t.eql(t.mul(d,O),t.mul(q,b)),A=t.eql(t.mul(m,O),t.mul(L,b));return B&&A}negate(){return new h(this.px,t.neg(this.py),this.pz)}double(){const{a,b:d}=e,m=t.mul(d,_t),{px:b,py:q,pz:L}=this;let O=t.ZERO,B=t.ZERO,A=t.ZERO,v=t.mul(b,b),T=t.mul(q,q),H=t.mul(L,L),R=t.mul(b,q);return R=t.add(R,R),A=t.mul(b,L),A=t.add(A,A),O=t.mul(a,A),B=t.mul(m,H),B=t.add(O,B),O=t.sub(T,B),B=t.add(T,B),B=t.mul(O,B),O=t.mul(R,O),A=t.mul(m,A),H=t.mul(a,H),R=t.sub(v,H),R=t.mul(a,R),R=t.add(R,A),A=t.add(v,v),v=t.add(A,v),v=t.add(v,H),v=t.mul(v,R),B=t.add(B,v),H=t.mul(q,L),H=t.add(H,H),v=t.mul(H,R),O=t.sub(O,v),A=t.mul(H,T),A=t.add(A,A),A=t.add(A,A),new h(O,B,A)}add(a){u(a);const{px:d,py:m,pz:b}=this,{px:q,py:L,pz:O}=a;let B=t.ZERO,A=t.ZERO,v=t.ZERO;const T=e.a,H=t.mul(e.b,_t);let R=t.mul(d,q),Z=t.mul(m,L),l=t.mul(b,O),p=t.add(d,m),y=t.add(q,L);p=t.mul(p,y),y=t.add(R,Z),p=t.sub(p,y),y=t.add(d,b);let I=t.add(q,O);return y=t.mul(y,I),I=t.add(R,l),y=t.sub(y,I),I=t.add(m,b),B=t.add(L,O),I=t.mul(I,B),B=t.add(Z,l),I=t.sub(I,B),v=t.mul(T,y),B=t.mul(H,l),v=t.add(B,v),B=t.sub(Z,v),v=t.add(Z,v),A=t.mul(B,v),Z=t.add(R,R),Z=t.add(Z,R),l=t.mul(T,l),y=t.mul(H,y),Z=t.add(Z,l),l=t.sub(R,l),l=t.mul(T,l),y=t.add(y,l),R=t.mul(Z,y),A=t.add(A,R),R=t.mul(I,y),B=t.mul(p,B),B=t.sub(B,R),R=t.mul(p,Z),v=t.mul(I,v),v=t.add(v,R),new h(B,A,v)}subtract(a){return this.add(a.negate())}is0(){return this.equals(h.ZERO)}wNAF(a){return S.wNAFCached(this,a,h.normalizeZ)}multiplyUnsafe(a){const{endo:d,n:m}=e;it("scalar",a,X,m);const b=h.ZERO;if(a===X)return b;if(this.is0()||a===F)return this;if(!d||S.hasPrecomputes(this))return S.wNAFCachedUnsafe(this,a,h.normalizeZ);let{k1neg:q,k1:L,k2neg:O,k2:B}=d.splitScalar(a),A=b,v=b,T=this;for(;L>X||B>X;)L&F&&(A=A.add(T)),B&F&&(v=v.add(T)),T=T.double(),L>>=F,B>>=F;return q&&(A=A.negate()),O&&(v=v.negate()),v=new h(t.mul(v.px,d.beta),v.py,v.pz),A.add(v)}multiply(a){const{endo:d,n:m}=e;it("scalar",a,F,m);let b,q;if(d){const{k1neg:L,k1:O,k2neg:B,k2:A}=d.splitScalar(a);let{p:v,f:T}=this.wNAF(O),{p:H,f:R}=this.wNAF(A);v=S.constTimeNegate(L,v),H=S.constTimeNegate(B,H),H=new h(t.mul(H.px,d.beta),H.py,H.pz),b=v.add(H),q=T.add(R)}else{const{p:L,f:O}=this.wNAF(a);b=L,q=O}return h.normalizeZ([b,q])[0]}multiplyAndAddUnsafe(a,d,m){const b=h.BASE,q=(O,B)=>B===X||B===F||!O.equals(b)?O.multiplyUnsafe(B):O.multiply(B),L=q(this,d).add(q(a,m));return L.is0()?void 0:L}toAffine(a){return g(this,a)}isTorsionFree(){const{h:a,isTorsionFree:d}=e;if(a===F)return!0;if(d)return d(h,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:a,clearCofactor:d}=e;return a===F?this:d?d(h,this):this.multiplyUnsafe(e.h)}toRawBytes(a=!0){return at("isCompressed",a),this.assertValidity(),o(h,this,a)}toHex(a=!0){return at("isCompressed",a),ut(this.toRawBytes(a))}}h.BASE=new h(e.Gx,e.Gy,t.ONE),h.ZERO=new h(t.ZERO,t.ONE,t.ZERO);const x=e.nBitLength,S=Me(h,e.endo?Math.ceil(x/2):x);return{CURVE:e,ProjectivePoint:h,normPrivateKeyToScalar:s,weierstrassEquation:i,isWithinCurveOrder:c}}function Qe(r){const e=ue(r);return mt(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}function tr(r){const e=Qe(r),{Fp:t,n}=e,o=t.BYTES+1,f=2*t.BYTES+1;function i(l){return P(l,n)}function c(l){return Ft(l,n)}const{ProjectivePoint:s,normPrivateKeyToScalar:u,weierstrassEquation:g,isWithinCurveOrder:w}=Je({...e,toBytes(l,p,y){const I=p.toAffine(),U=t.toBytes(I.x),N=pt;return at("isCompressed",y),y?N(Uint8Array.from([p.hasEvenY()?2:3]),U):N(Uint8Array.from([4]),U,t.toBytes(I.y))},fromBytes(l){const p=l.length,y=l[0],I=l.subarray(1);if(p===o&&(y===2||y===3)){const U=ot(I);if(!At(U,F,t.ORDER))throw new Error("Point is not on curve");const N=g(U);let V;try{V=t.sqrt(N)}catch(C){const D=C instanceof Error?": "+C.message:"";throw new Error("Point is not on curve"+D)}const M=(V&F)===F;return(y&1)===1!==M&&(V=t.neg(V)),{x:U,y:V}}else if(p===f&&y===4){const U=t.fromBytes(I.subarray(0,t.BYTES)),N=t.fromBytes(I.subarray(t.BYTES,2*t.BYTES));return{x:U,y:N}}else{const U=o,N=f;throw new Error("invalid Point, expected length of "+U+", or uncompressed "+N+", got "+p)}}}),h=l=>ut(lt(l,e.nByteLength));function x(l){const p=n>>F;return l>p}function S(l){return x(l)?i(-l):l}const E=(l,p,y)=>ot(l.slice(p,y));class a{constructor(p,y,I){this.r=p,this.s=y,this.recovery=I,this.assertValidity()}static fromCompact(p){const y=e.nByteLength;return p=G("compactSignature",p,y*2),new a(E(p,0,y),E(p,y,2*y))}static fromDER(p){const{r:y,s:I}=_.toSig(G("DER",p));return new a(y,I)}assertValidity(){it("r",this.r,F,n),it("s",this.s,F,n)}addRecoveryBit(p){return new a(this.r,this.s,p)}recoverPublicKey(p){const{r:y,s:I,recovery:U}=this,N=O(G("msgHash",p));if(U==null||![0,1,2,3].includes(U))throw new Error("recovery id invalid");const V=U===2||U===3?y+e.n:y;if(V>=t.ORDER)throw new Error("recovery id 2 or 3 invalid");const M=U&1?"03":"02",C=s.fromHex(M+h(V)),D=c(V),tt=i(-N*D),K=i(I*D),$=s.BASE.multiplyAndAddUnsafe(C,tt,K);if(!$)throw new Error("point at infinify");return $.assertValidity(),$}hasHighS(){return x(this.s)}normalizeS(){return this.hasHighS()?new a(this.r,i(-this.s),this.recovery):this}toDERRawBytes(){return ht(this.toDERHex())}toDERHex(){return _.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return ht(this.toCompactHex())}toCompactHex(){return h(this.r)+h(this.s)}}const d={isValidPrivateKey(l){try{return u(l),!0}catch{return!1}},normPrivateKeyToScalar:u,randomPrivateKey:()=>{const l=fe(e.n);return De(e.randomBytes(l),e.n)},precompute(l=8,p=s.BASE){return p._setWindowSize(l),p.multiply(BigInt(3)),p}};function m(l,p=!0){return s.fromPrivateKey(l).toRawBytes(p)}function b(l){const p=st(l),y=typeof l=="string",I=(p||y)&&l.length;return p?I===o||I===f:y?I===2*o||I===2*f:l instanceof s}function q(l,p,y=!0){if(b(l))throw new Error("first arg must be private key");if(!b(p))throw new Error("second arg must be public key");return s.fromHex(p).multiply(u(l)).toRawBytes(y)}const L=e.bits2int||function(l){if(l.length>8192)throw new Error("input is too large");const p=ot(l),y=l.length*8-e.nBitLength;return y>0?p>>BigInt(y):p},O=e.bits2int_modN||function(l){return i(L(l))},B=Vt(e.nBitLength);function A(l){return it("num < 2^"+e.nBitLength,l,X,B),lt(l,e.nByteLength)}function v(l,p,y=T){if(["recovered","canonical"].some(et=>et in y))throw new Error("sign() legacy options not supported");const{hash:I,randomBytes:U}=e;let{lowS:N,prehash:V,extraEntropy:M}=y;N==null&&(N=!0),l=G("msgHash",l),Wt(y),V&&(l=G("prehashed msgHash",I(l)));const C=O(l),D=u(p),tt=[A(D),A(C)];if(M!=null&&M!==!1){const et=M===!0?U(t.BYTES):M;tt.push(G("extraEntropy",et))}const K=pt(...tt),$=C;function Et(et){const dt=L(et);if(!w(dt))return;const bt=c(dt),gt=s.BASE.multiply(dt).toAffine(),ft=i(gt.x);if(ft===X)return;const rt=i(bt*i($+ft*D));if(rt===X)return;let wt=(gt.x===ft?0:2)|Number(gt.y&F),jt=rt;return N&&x(rt)&&(jt=S(rt),wt^=1),new a(ft,jt,wt)}return{seed:K,k2sig:Et}}const T={lowS:e.lowS,prehash:!1},H={lowS:e.lowS,prehash:!1};function R(l,p,y=T){const{seed:I,k2sig:U}=v(l,p,y),N=e;return ee(N.hash.outputLen,N.nByteLength,N.hmac)(I,U)}s.BASE._setWindowSize(8);function Z(l,p,y,I=H){var U;const N=l;p=G("msgHash",p),y=G("publicKey",y);const{lowS:V,prehash:M,format:C}=I;if(Wt(I),"strict"in I)throw new Error("options.strict was renamed to lowS");if(C!==void 0&&C!=="compact"&&C!=="der")throw new Error("format must be compact or der");const D=typeof N=="string"||st(N),tt=!D&&!C&&typeof N=="object"&&N!==null&&typeof N.r=="bigint"&&typeof N.s=="bigint";if(!D&&!tt)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let K,$;try{if(tt&&(K=new a(N.r,N.s)),D){try{C!=="compact"&&(K=a.fromDER(N))}catch(wt){if(!(wt instanceof _.Err))throw wt}!K&&C!=="der"&&(K=a.fromCompact(N))}$=s.fromHex(y)}catch{return!1}if(!K||V&&K.hasHighS())return!1;M&&(p=e.hash(p));const{r:Et,s:et}=K,dt=O(p),bt=c(et),gt=i(dt*bt),ft=i(Et*bt),rt=(U=s.BASE.multiplyAndAddUnsafe($,gt,ft))==null?void 0:U.toAffine();return rt?i(rt.x)===Et:!1}return{CURVE:e,getPublicKey:m,getSharedSecret:q,sign:R,verify:Z,ProjectivePoint:s,Signature:a,utils:d}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function er(r){return{hash:r,hmac:(e,...t)=>ne(r,e,le(...t)),randomBytes:de}}function rr(r,e){const t=n=>tr({...r,...er(n)});return{...t(e),create:t}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const he=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),Xt=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),nr=BigInt(1),zt=BigInt(2),$t=(r,e)=>(r+e/zt)/e;function or(r){const e=he,t=BigInt(3),n=BigInt(6),o=BigInt(11),f=BigInt(22),i=BigInt(23),c=BigInt(44),s=BigInt(88),u=r*r*r%e,g=u*u*r%e,w=j(g,t,e)*g%e,h=j(w,t,e)*g%e,x=j(h,zt,e)*u%e,S=j(x,o,e)*x%e,E=j(S,f,e)*S%e,a=j(E,c,e)*E%e,d=j(a,s,e)*a%e,m=j(d,c,e)*E%e,b=j(m,t,e)*g%e,q=j(b,i,e)*S%e,L=j(q,n,e)*u%e,O=j(L,zt,e);if(!Tt.eql(Tt.sqr(O),r))throw new Error("Cannot find square root");return O}const Tt=ie(he,void 0,void 0,{sqrt:or}),ir=rr({a:BigInt(0),b:BigInt(7),Fp:Tt,n:Xt,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:r=>{const e=Xt,t=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),n=-nr*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),o=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),f=t,i=BigInt("0x100000000000000000000000000000000"),c=$t(f*r,e),s=$t(-n*r,e);let u=P(r-c*t-s*o,e),g=P(-c*n-s*f,e);const w=u>i,h=g>i;if(w&&(u=e-u),h&&(g=e-g),u>i||g>i)throw new Error("splitScalar: Endomorphism failed, k="+r);return{k1neg:w,k1:u,k2neg:h,k2:g}}}},Se);BigInt(0);ir.ProjectivePoint;export{ir as secp256k1};
